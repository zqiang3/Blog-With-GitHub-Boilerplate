<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>君祁的技术博客</title><link>/Blog-With-GitHub-Boilerplate/</link><description>只有一种英雄主义，就是看清生活真相之后依然热爱生活。</description><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>/Blog-With-GitHub-Boilerplate/logo.png</url><title>君祁的技术博客</title><link>/Blog-With-GitHub-Boilerplate/</link></image><language>zh-CN</language><lastBuildDate>Thu, 24 Jun 2021 09:33:47 +0806</lastBuildDate><pubDate>Thu, 24 Jun 2021 09:33:47 +0806</pubDate><item><title>TCP</title><link>/Blog-With-GitHub-Boilerplate/archives/tcp/</link><description>&lt;h2&gt;TCP&lt;/h2&gt;
&lt;p&gt;在socket编程中，当客户端执行&lt;code&gt;connect()&lt;/code&gt;时，将触发三次握手。建立TCP连接时，客户端和服务端，总共需要发送三个包。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一次握手(SYN=1, seq=x)&lt;/p&gt;
&lt;p&gt;客户端发送第一个包，SYN标志位为1，序列号为x。发送完毕后，客户端进入&lt;code&gt;SYN_SENT&lt;/code&gt;状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二次握手(SYN=1, ACK=1, seq=y, ACKNum=x+1)&lt;/p&gt;
&lt;p&gt;服务端返回确认包并发送一个SYN包，SYN标志位与ACK标志位都设为1，服务端设置自己的序列号y，同时将确认序号设置为客户端的序列号加1，即x+1。发送完毕后，
服务端进入&lt;code&gt;SYN_RCVD&lt;/code&gt;状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三次握手(ACK=1, ACKNum=y+1)&lt;/p&gt;
&lt;p&gt;客户端再次发送确认包。ACK标志位设置为1，确认序号设为服务端的序列号加1，即y+1。发送完毕后，客户端进入&lt;code&gt;ESTABLISHED&lt;/code&gt;状态。当服务端收到这个包后，
也进入&lt;code&gt;ESTABLISHED&lt;/code&gt;状态。TCP三次握手过程结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在socket编程中，客户端或服务端任何一方执行&lt;code&gt;close()&lt;/code&gt;操作即可产生挥手动作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一次挥手(FIN=1, seq=x)&lt;/p&gt;
&lt;p&gt;主动关闭的一方（假设是客户端）发送FIN标志位为1的包，同时带上序列号x，表示不再发送数据，但仍然可以接收数据。发送完毕后，进行&lt;code&gt;FIN_WAIT_1&lt;/code&gt;状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二次挥手(ACK=1, ACKNum=x+1)&lt;/p&gt;
&lt;p&gt;被动关闭的一方（假设为服务端）确认客户端的FIN包，发送一个确认包，确认号设为x+1，服务端进入&lt;code&gt;CLOSE_WAIT&lt;/code&gt;状态，客户端收到这个包后，进行&lt;code&gt;FIN_WAIT_2&lt;/code&gt;状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三次挥手(FIN=1, seq=y)&lt;/p&gt;
&lt;p&gt;服务端可以关闭连接了，向客户端发送关闭连接请求，将FIN标志位设为1，同时带上序列号y，发送完毕后，进行&lt;code&gt;LASK_ACK&lt;/code&gt;状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第四次挥手(ACK=1, ACKNum=y+1)&lt;/p&gt;
&lt;p&gt;客户端收到服务端的关闭连接请求后，返回一个确认包。发送后进入&lt;code&gt;TIME_WAIT&lt;/code&gt;状态。服务端收到确认包后，进行&lt;code&gt;CLOSED&lt;/code&gt;状态。客户端等待2倍的MSL时间后，
没有再收到网络包也进入&lt;code&gt;CLOSED&lt;/code&gt;状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="640" data-height="716" src="/Blog-With-GitHub-Boilerplate/archives/assets/e8772faa1e0dab73cacdd39a590f9539.jpg" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;为什么TIME_WAIT状态要保持2MSL？&lt;/h2&gt;
&lt;p&gt;MSL是报文在网络中的最大生存时间，超过这个时间报文将被丢弃。&lt;/p&gt;
&lt;p&gt;维持TIME_WAIT状态的目的有两个&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了可靠地关闭TCP连接，确保当前连接的所有报文在网络上彻底消失&lt;/li&gt;
&lt;li&gt;为了能正确处理延迟的重复报文，如果前后两个连接使用相同的网络四元组，避免前一个连接对后一个连接的影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP连接中的一端在发送了FIN报文后如果没有收到相应的ACK报文，则会反复多次重传FIN报文，大约持续几分钟。处于TIME_WAIT状态的一端在收到重传的FIN报文时会重新计时。&lt;/p&gt;
&lt;p&gt;为什么需要2倍的MSL呢？
第一个MSL是为了保证客户端发送的ACK生命周期结束，第二个MSL是确保服务端发送的FIN生命周期结束。&lt;/p&gt;
&lt;p&gt;客户端发送ACK，经过多长时间到达服务是不知道的，假设这个时间为t，则0&amp;lt;t&amp;lt;MSL。如果服务端没有收到ACK，会重传FIN，FIN也需要经过最大MSL的时间到达客户端，
因此TIME_WAIT需要维持2MSL才能收到重传的FIN报文。&lt;/p&gt;
&lt;h2&gt;什么是MTU&lt;/h2&gt;
&lt;p&gt;最大传输单元，1500bytes&lt;/p&gt;
&lt;h2&gt;TCP与UDP的区别&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;TCP&lt;/th&gt;
&lt;th&gt;UDP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;是否建立连接&lt;/td&gt;
&lt;td&gt;面向连接，三次握手&lt;/td&gt;
&lt;td&gt;无连接，不需要握手&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;面向字节流&lt;/td&gt;
&lt;td&gt;面向数据报&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可靠性&lt;/td&gt;
&lt;td&gt;可靠：无差错，不丢失，不重复，按序到达，有确认、重传机制&lt;/td&gt;
&lt;td&gt;不可靠，最大努力交付，不保证可靠性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;端到端&lt;/td&gt;
&lt;td&gt;一对一，一对多，多对多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;有拥塞控制，流量控制&lt;/td&gt;
&lt;td&gt;无握手、确认、重传、拥塞控制机制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;协议头&lt;/td&gt;
&lt;td&gt;首部开销大，20字节&lt;/td&gt;
&lt;td&gt;开销小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;速度&lt;/td&gt;
&lt;td&gt;慢，效率低，占用系统资源高&lt;/td&gt;
&lt;td&gt;UDP更快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设计复杂度&lt;/td&gt;
&lt;td&gt;复杂&lt;/td&gt;
&lt;td&gt;简单&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;全双工&lt;/td&gt;
&lt;td&gt;全双工&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;TCP的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;慢，效率低，占用系统资源高&lt;/li&gt;
&lt;li&gt;三次握手机制，易被攻击（DOS, DDOS, CC）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UDP的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可靠，不稳定，丢包&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;适用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP适用可靠传输的场景，对网络通讯要求高。&lt;/li&gt;
&lt;li&gt;UDP适用于对网络通讯质量要求不高的场景，如音视频传输。&lt;/li&gt;
&lt;/ul&gt;
</description><author>zqiang33@163.com (君祁)</author><guid isPermaLink="true">/Blog-With-GitHub-Boilerplate/archives/tcp/</guid><pubDate>Wed, 16 Jun 2021 15:07:17 +0806</pubDate></item><item><title>MySQL</title><link>/Blog-With-GitHub-Boilerplate/archives/mysql/</link><description>&lt;h2&gt;聚簇索引与非聚簇索引&lt;/h2&gt;
&lt;p&gt;聚簇索引(clustered index)：聚簇索引的叶节点存储了整行数据。&lt;/p&gt;
&lt;p&gt;非聚簇索引：索引树的叶子节点只存储索引字段和主键的值，不存放整行数据。非聚簇索引也称为二级索引。&lt;/p&gt;
&lt;p&gt;聚簇索引与非聚簇索引的区别是：是否存放完整的整行记录。&lt;/p&gt;
&lt;p&gt;InnoDB主键使用的是聚簇索引，MyISAM所有的索引（包括主键索引）使用的都是非聚簇索引。&lt;/p&gt;
&lt;h2&gt;MySQL的聚簇索引一定是主键吗？&lt;/h2&gt;
&lt;p&gt;在InnoDB中，聚集索引不一定是主键，但主键一定是聚集索引。如果没有为表定义主键，聚集索引会被设为第一个不为NULL的唯一索引，如果也没有这样的唯一索引，
InnoDB 会选择内置 6 字节长的 ROWID 作为隐含的聚集索引。&lt;/p&gt;
&lt;h2&gt;COUNT(*) COUNT(1) COUNT(id) COUNT(COLUMN)有区别吗？&lt;/h2&gt;
&lt;p&gt;先说结论，在高版本的MySQL（5.5及以后），count(1)比count(*)是没有区别的。&lt;/p&gt;
&lt;p&gt;COUNT(COLUMN)在统计某个列值的数量时，不会统计NULL。当COUNT内的表达式确定不为NULL时，实际上是在统计所有行数。&lt;/p&gt;
&lt;p&gt;如果表只有一个主键索引，没有其他二级索引，那么&lt;code&gt;COUNT(*)&lt;/code&gt;与&lt;code&gt;COUNT(1)&lt;/code&gt;都是通过主键索引统计行数的。如果该表有二级索引，&lt;code&gt;COUNT(*)&lt;/code&gt;与&lt;code&gt;COUNT(1)&lt;/code&gt;
会用&lt;strong&gt;占用空间最小&lt;/strong&gt;的二级索引字段作统计。&lt;/p&gt;
&lt;p&gt;为什么：InnoDB这样操作的原因是为了减少IO次数，因为数据库的瓶颈在IO，通过选择占用空间最小的非NULL索引来统计所有行数，尽可能地减小IO。&lt;/p&gt;
&lt;p&gt;补充：MyISAM在统计表的总行数时会很快，原因是MyISAM对于表的行数作了优化，具体做法有一个变量用于存储表的总行数。但是，如果加了WHERE查询条件，该优化将不起作用。&lt;/p&gt;
&lt;h2&gt;辟谣：MySQL中使用IS NULL, IS NOT NULL, != 不能使用索引？胡扯！&lt;/h2&gt;
&lt;p&gt;NULL值是怎么在记录中存储的：在MySQL中，每一条记录都有固定的格式，以compact格式为会例，在compact格式下，会有一部分记录NULL值列表。NULL值列表是怎么表示的呢？
首先会统计表中所有可以为NULL的列，然后每个允许为NULL的列对应一个二进制位，逆序排列。如果二进制位为1，表示该列的值为NULL,如果为0表示该列的值不为NULL。另外，
二进制位的个数是整数个字节。&lt;/p&gt;
&lt;p&gt;键值为NULL的记录怎么在B+树中存放的？答案是放在B+树的最左边。原因是InnoDB有这样的规定：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;We define the SQL null to be the smallest possible value of a field.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;补充：NULL字段的数据，只能使用IS NULL查询出来，使用= NULL或!= VALUE都不会查出NULL的数据。
当使用COUNT(COLUMN)函数进行统计时，NULL的数据不会被计入统计。
判断列值是否为NULL，必须使用IS NULL和IS NOT NULL。不能使用= NULL或!= NULL，因为在MySQL中，NULL与任何值比较永远返回NULL。&lt;/p&gt;
&lt;h2&gt;有哪些语句会造成MySQL做全表扫描？&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;语句&lt;/th&gt;
&lt;th&gt;是否使用索引&lt;/th&gt;
&lt;th&gt;是否使用全表扫描&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;IS NULL&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IS NOT NULL&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IN&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NOT IN&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COUNT(*)&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LIKE '%xxx'&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使不使用索引的依据是什么？&lt;/p&gt;
&lt;p&gt;IS NULL、IS NOT NULL、!=这些条件都可能使用到索引，那到底什么时候索引，什么时候采用全表扫描呢？&lt;/p&gt;
&lt;p&gt;答案是：数据库会根据查询的成本决定何时走索引查询，何时做全表扫描。对二级索引来说，成本主要有两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取二级索引记录的成本&lt;/li&gt;
&lt;li&gt;执行回表操作的成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当执行回表操作的次数比较多，达到一定比例时，数据库经过计算分析使用二级索引再回表的查询成本超过了全表扫描的成本，就会使用全表扫描。&lt;/p&gt;
&lt;h2&gt;InnoDB的事务隔离是如何实现的？&lt;/h2&gt;
&lt;h3&gt;四种隔离级别&lt;/h3&gt;
&lt;p&gt;未提交读(read uncommitted)，提交读(read committed)，可重复读(repeatable read)，串行化(serializable)。&lt;/p&gt;
&lt;p&gt;标准SQL事务隔离级别的实现是依赖锁的，但使用锁的方式实现隔离级别需要频繁地加解锁，很容易出现读写冲突。为了不加锁解决读写冲突的问题，MySQL引入的MVCC机制。
在读提交和可重复读的隔离级别下，InnoDB会创建一个视图（快照），访问数据的时候以视图的逻辑结果为准。在可重复读的隔离级别下，这个视图是在事务启动时创建的。
在读提交的隔离级别下，视图是在每条sql语句开始执行时创建的。在读未提交的隔离级别下，不提供隔离措施，不会创建视图，但更新某行数据时加共享锁。
串行化的隔离级别是通过加锁的方式避免并行访问。&lt;/p&gt;
&lt;h3&gt;锁定读和一致性非锁定读&lt;/h3&gt;
&lt;p&gt;锁定读：在一个事务中进行查询时，主动给读加锁。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SELECT ... LOCK IN SHARE MODE  &lt;span class="c1"&gt;# 加了行共享锁&lt;/span&gt;
SELECT ... FOR UPDATE  &lt;span class="c1"&gt;# 加了行排他锁&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一致性非锁定读：
事务在进行查询时，数据库通过使用MVCC提供某个时间点的数据快照，查询会看到该时间点之前事务对数据的更改，而不会看到该时间点之后事务对数据的更改或未提交的更改。
consistent read是InnoDB在RC和RR隔离级别下进行SELECT查询的默认模式。&lt;/p&gt;
&lt;h3&gt;当前读和快照读&lt;/h3&gt;
&lt;p&gt;当前读：当前读读取的是数据的最新版本，像UPDATE, DELETE, INSERT, SELECT ... LOCK IN SHARE MODE, SELECT ... FOR UPDATE等操作都是当前读。
当前读要保证其他并发事务不会修改当前读取的数据，会对相应记录加锁。&lt;/p&gt;
&lt;p&gt;快照读：快照读读取的数据是快照版本，也就是历史版本，像不加锁的SELECT就是快照读。快照读的前提是不在未提交读和串行化的隔离级别下，因为未提交读问题读取最新的数据，串行化则是对表加锁。&lt;/p&gt;
&lt;h3&gt;InnoDB对事务的实现&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;事务隔离级别&lt;/th&gt;
&lt;th&gt;实现方式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;未提交读&lt;/td&gt;
&lt;td&gt;读数据不加锁，都是当前读；更新数据，加行级共享锁，直到事务结束才释放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;提交读&lt;/td&gt;
&lt;td&gt;读数据不加锁，都是快照读；更新数据，加行级排他锁，直到事务结束才释放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可重复读&lt;/td&gt;
&lt;td&gt;读数据不加锁，都是快照读；更新数据时，加行级排他锁，间隙锁，直到事务结束才释放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;串行化&lt;/td&gt;
&lt;td&gt;读取数据时，加表级共享锁，都是当前读；更新数据时，加表级排他锁，直到事务结束才释放&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在RR隔离级别下，InnoDB通过快照读，解决了不可重复读的问题，通过间隙锁，解决了幻读的问题。
通过MVCC，InnoDB可以在RC隔离级别解决不可重复读的问题，可以在RR隔离级别解决幻读的问题。&lt;/p&gt;
&lt;h2&gt;InnoDB加锁处理分析&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://tech.meituan.com/2014/08/20/innodb-lock.html"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MVCC(Multi-Version Concurrency Control)：多版本并发控制
Lock-Based Concurrency Control：基于锁的并发控制&lt;/p&gt;
&lt;p&gt;两段锁：加锁阶段和解锁阶段&lt;/p&gt;
&lt;p&gt;MVCC的好处：读不加锁，读写不冲突，极大地提高系统的并发能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;索引对加锁的影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考虑下面的表和更新语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;create table t(
c int
);

insert into t values(1);
insert into t values(5);
insert into t values(10);

update t set c = 100 where c = 1;

alter table t add index id_c (c);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c字段加索引与不加索引有区别吗？事实上，如果不给c字段加索引，上面的更新语句会把整张表的所有数据行加行锁。这听起来有点不可思议，但是sql运行过程中，
由于没有索引，存储引擎无法通过索引快速过滤，就会将所有记录加锁后，全部返回给server层进行过滤。&lt;/p&gt;
&lt;p&gt;但在实际使用过程当中，MySQL做了一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录释放锁 (违背了二段锁协议的约束)。
这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。可见即使是MySQL，为了效率也是会违反规范的。（参见《高性能MySQL》中文第三版p181）&lt;/p&gt;
&lt;h2&gt;解决不可重复读，使用MVCC与使用锁实现的区别&lt;/h2&gt;
&lt;p&gt;InnoDB在RR（可重复读）隔离级别下，在事务开始时开启一个快照，在整个事务期间读的都是相同的快照数据，因此没有不可重复读的问题。
MVCC使用快照读解决不可重复读的问题，不需要加锁。&lt;/p&gt;
&lt;p&gt;使用锁来解决不可重复读，需要在读数据时加锁，这样其他事务在解锁前就无法修改这些数据了。锁只能锁住已经存在的数据，却无法锁住insert的数据，
因此不能解决幻读的问题。使用锁还会导致读写冲突，降低数据库的并发能力。&lt;/p&gt;
&lt;h2&gt;悲观锁与乐观锁&lt;/h2&gt;
&lt;p&gt;悲观锁与乐观锁是两种不同的思想，用于解决并发场景下的数据竞争问题。&lt;/p&gt;
&lt;p&gt;悲观锁需要加真实的锁，读取数据时加共享锁（读锁），写数据时加排他锁（写乐）。&lt;/p&gt;
&lt;p&gt;乐观锁并不真正加锁，只是在更新数据的时候判断一下数据是不是已经被修改，如果数据被修改则放弃操作，否则执行操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乐观锁的实现方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CAS&lt;/li&gt;
&lt;li&gt;版本号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CAS操作逻辑如下：如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。&lt;/p&gt;
&lt;p&gt;版本号机制的基本思路是在数据中增加一个字段version，表示数据的版本号，每当数据被修改时，版本号加1。当查询数据时，将该数据的版本号一起查出来；
更新数据时，判断一下当前版本号与之前读取的版本号是否一致，如果一致才进行操作，否则放弃操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAS缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ABA问题&lt;/li&gt;
&lt;li&gt;如果并发冲突严重，CAS机制会频繁失败，一直重试，消耗CPU严重。&lt;/li&gt;
&lt;li&gt;CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;InnoDB中MVCC的实现&lt;/h2&gt;
&lt;p&gt;在InnoDB中，每行数据会有两个额外的值来实现MVCC，一个值记录这行数据何时被创建，一个值记录这行数据何时过期（或者被删除）。实际中这个值存储的是事务的版本号，
每开启一个新事务，事务的版本号就会加1。&lt;/p&gt;
&lt;p&gt;读取数据时，只会读到小于等于当前事务版本号的数据。通过MVCC，虽然每行记录都需要额外的存储空间，但可以减少锁的使用，大多数读操作都不用加锁。&lt;/p&gt;
&lt;h3&gt;RR隔离级别下，如何解决幻读？&lt;/h3&gt;
&lt;p&gt;在RR隔离级别下，只靠MVCC，可以解决幻读吗？&lt;/p&gt;
&lt;p&gt;如果只是快照读&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin;

#假设users表为空，下面查出来的数据为空

select * from users; #没有加锁

#此时另一个事务提交了，且插入了一条id=1的数据

select * from users; #读快照，查出来的数据为空

update users set name='mysql' where id=1;#update是当前读，所以更新成功，并生成一个更新的快照

select * from users; #读快照，查出来id为1的一条记录，因为MVCC可以查到当前事务生成的快照

commit;&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;begin;

#假设users表为空，下面查出来的数据为空

select * from users lock in share mode; #加上共享锁

#此时另一个事务B想提交且插入了一条id=1的数据，由于有间隙锁，所以要等待

select * from users; #读快照，查出来的数据为空

update users set name='mysql' where id=1;#update是当前读，由于不存在数据，不进行更新

select * from users; #读快照，查出来的数据为空

commit;

#事务B提交成功并插入数据&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意: RR模式下想解决幻读问题，需要我们显式加锁，不然查询的时候还是不会加锁的。&lt;/p&gt;
&lt;p&gt;在RR级别下，事务A在update后加锁，可以避免幻读，加的这个锁，就是间隙锁。行锁和间隙锁的合并，称为Next-Key锁。&lt;/p&gt;
&lt;p&gt;修改数据后，不仅会在相应的行加行锁，同时也会在数据行两边的区间，加上间隙锁。这样其他事务就无法在两边的区间insert新的数据。&lt;/p&gt;
&lt;p&gt;行锁防止别的事务修改或删除数据，GAP锁该上别的事务新增数据，行锁和GAP锁结合共同解决了RR级别在写数据时的幻读问题。&lt;/p&gt;
</description><author>zqiang33@163.com (君祁)</author><guid isPermaLink="true">/Blog-With-GitHub-Boilerplate/archives/mysql/</guid><pubDate>Wed, 16 Jun 2021 15:07:17 +0806</pubDate></item><item><title>HTTP</title><link>/Blog-With-GitHub-Boilerplate/archives/http/</link><description>&lt;h2&gt;HTTP2的特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;多路复用&lt;/li&gt;
&lt;li&gt;头部压缩&lt;/li&gt;
&lt;li&gt;服务器推送&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多路复用允许单一的连接同时发起多重的请求-响应。
实现的原理是通过二进制分帧，HTTP/2将所有传输的信息分割为帧，并对它们采用二进制格式的编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;头部压缩的原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在HTTP/1中，请求和响应都是由状态行、请求/响应头部、消息主体三部分组成，一般消息主体都会经过gzip压缩，或者本身就是经过压缩后的二进制文件（图片、
音频），但状态行和头部却是以纯文本传输的，没有经过任何的压缩。&lt;/p&gt;
&lt;p&gt;HTTP/2对头部数据也进行了压缩，并且在客户端和服务端之间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护一份相同的静态字典，包含常见的头部名称，以及特别常见的头部名称与值的组合。&lt;/li&gt;
&lt;li&gt;维护一份相同的动态字典，可以动态地添加内容。&lt;/li&gt;
&lt;li&gt;支持哈夫曼编码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于完全匹配的头部键值对，例如method: GET，可以直接使用一个字符表示。&lt;/li&gt;
&lt;li&gt;对于头部名称可以匹配的键值对，例如cookie: xxx，可以将名称使用一个字符表示。&lt;/li&gt;
&lt;li&gt;对于不完全匹配静态字典的键值对，可以添加到动态字典中，在后续的请求中也可以使用一个字符表示了。&lt;/li&gt;
&lt;li&gt;对于在静态、动态字典中都不存在的内容，可以使用哈夫曼编码来减小体积。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;HTTP1.1的pipeline与HTTP/2的多路复用有什么区别？&lt;/h2&gt;
&lt;p&gt;网上有一张图，对HTTP1.1与HTTP/2在网络通信的差异进行了对比。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1602" data-height="1588" src="/Blog-With-GitHub-Boilerplate/archives/assets/08f37543e79bd131bd11b266e61b719b.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;HTTP1.0使用的是短连接，每次请求响应完成会断开连接，效率非常低。&lt;/p&gt;
&lt;p&gt;HTTP1.1增加了支持持久化连接，也就是长连接，在一个连接上可以进行多次请求/响应。但是多个请求/响应只能串行，后一个请求/响应只能在前一个请求/响应完成后才能发起。&lt;/p&gt;
&lt;p&gt;HTTP1.1提供了管线化技术，可以将多个http请求打包在一起发给服务端，但是返回的响应也必须是按请求的顺序返回，如果某个请求耗时很长，就会阻塞后面的请求，有队头阻塞问题。&lt;/p&gt;
&lt;p&gt;HTTP/2提出了多路复用技术，在一个tcp连接上可以并行多个请求/响应，不同请求/响应之间互不影响。原理是将消息分成多个二进制帧，二进制帧带有更多信息，标识自己属于哪个请求/响应，
这样多个请求/响应可以并行处理，不会相互阻塞。&lt;/p&gt;
</description><author>zqiang33@163.com (君祁)</author><guid isPermaLink="true">/Blog-With-GitHub-Boilerplate/archives/http/</guid><pubDate>Thu, 17 Jun 2021 14:47:10 +0806</pubDate></item><item><title>HashMap的实现原理</title><link>/Blog-With-GitHub-Boilerplate/archives/hashmap/</link><description>&lt;p&gt;&lt;a href="https://blog.csdn.net/weixin_44015043/article/details/105346187"&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;HashMap的实现原理&lt;/h2&gt;
&lt;p&gt;JDK1.7中使用的是数组+链表。&lt;/p&gt;
&lt;p&gt;JDK1.8中使用的是数组+链表+红黑树。当链表长度大于8时，会将链表转化为红黑树；当链表长度小于6时，会将红黑树转化为链表。&lt;/p&gt;
&lt;p&gt;算法过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据key的hashcode做散列，计算出数组内对应的下标值。&lt;/li&gt;
&lt;li&gt;如果数组中对应的位置为空，说明没有发生哈希碰撞冲突，就直接放在该位置。&lt;/li&gt;
&lt;li&gt;如果发生了哈希碰撞，且下面是链表结构，链表长度小于8，就放到链表里（JDK1.8放在尾部，JDK1.7放在头部）；如果添加后链表长度大于8，
就将链表转化为红黑树的结构。&lt;/li&gt;
&lt;li&gt;如果发生了哈希碰撞，且下面是红黑树结构，就将新元素插入到红黑树中。&lt;/li&gt;
&lt;li&gt;进行扩容检测，如果需要扩容，将数组进行2倍扩容，并将老数组中的所有元素取出来重新进行hash散列，再放到新数组中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="634" data-height="441" src="/Blog-With-GitHub-Boilerplate/archives/assets/5429d84584ae3be5f41df2a60e2289a0.jpg" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;为什么使用数组而不是链表？&lt;/h2&gt;
&lt;p&gt;数组的查询时间复杂度是O(1)，通过散列函数计算出数组的下标，可以直接定位到节点的位置。&lt;/p&gt;
&lt;p&gt;使用底层数组，不使用ArrayList，可以自定义扩容机制，而ArrayList是1.5倍扩容。&lt;/p&gt;
&lt;h2&gt;如何计算数组的下标值？&lt;/h2&gt;
&lt;p&gt;根据key取得hashcode后，将它与数组的长度减1进行与运算，得出下标值。
进行与操作时，计算只用到了最后几位，导致所生成的下标值不能够完全散列。
解决方式是将hashcode的高16位与低16位进行异或操作，得到的值再进行相与，得到最终散列的下标值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hashCode&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tab&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;tab&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description><author>zqiang33@163.com (君祁)</author><guid isPermaLink="true">/Blog-With-GitHub-Boilerplate/archives/hashmap/</guid><pubDate>Thu, 17 Jun 2021 14:47:10 +0806</pubDate></item><item><title>redis设计与实现</title><link>/Blog-With-GitHub-Boilerplate/archives/redis/</link><description>&lt;h2&gt;简单动态字符串(SDS)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sdshdr&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;常数时间获取字符串长度。&lt;/li&gt;
&lt;li&gt;杜绝缓冲区溢出。SDS在修改数据之前，会先检查空间是否足够，不够会先拓展空间，再执行操作。&lt;/li&gt;
&lt;li&gt;通过内存预分配和惰性空间释放减少内存重分配次数。c字符串修改字符串长度N次需要执行N次内存重分配，SDS最多执行N次内存重分配。&lt;/li&gt;
&lt;li&gt;二进制安全。c字符采用0字符标识末尾，因此不能保存图片，音视频，压缩文件，SDS采用len记录长度，不存在这种问题，因此可以保存各种各样的格式。&lt;/li&gt;
&lt;li&gt;兼容部分c字符串函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;链表&lt;/h2&gt;
&lt;p&gt;在 Redis3.2 之前，链表采用了 ZipList 和 LinkedList 实现的，在 3.2 之后，List 底层采用了 QuickList。
&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;listNode&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;listNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;listNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;listNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;list&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;listNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;listNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dup&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;双端：带有prev和next指针&lt;/li&gt;
&lt;li&gt;无环：表头节点的 prev 指针和表尾节点的 next 都指向NULL&lt;/li&gt;
&lt;li&gt;带表头和表尾指针&lt;/li&gt;
&lt;li&gt;保存了链表长度&lt;/li&gt;
&lt;li&gt;多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;跳跃表&lt;/h2&gt;
&lt;p&gt;链接：&lt;a href="https://www.jianshu.com/p/9d8296562806"&gt;跳跃表的实现（全网最详细的分析）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;zskiplistNode&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;zskiplistNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;backward&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;score&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;robj&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;zskiplistLevel&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;skiplistNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;span&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="p"&gt;[];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;skiplistNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;zskiplist&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;zskiplistNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 表头节点的层高不会记录&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;zskiplist&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;跳跃表由以下几部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表头：不存储元素，负责维护指向第一个元素各层的指针。&lt;/li&gt;
&lt;li&gt;表尾：全部由NULL组成，表示每一层链表的结尾。&lt;/li&gt;
&lt;li&gt;跳跃表节点：保存元素值，以及多个层。&lt;/li&gt;
&lt;li&gt;层：保存指向其他层的指针。高层的指针越过的元素数量大于等于低层的指针。查询时总是从高层的先开始搜索，然后慢慢降低层次，直到找到相应的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="-1" data-height="-1" src="https://user-gold-cdn.xitu.io/2019/6/17/16b650948652b4ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="跳跃表的数据结构" /&gt;&lt;figcaption&gt;跳跃表的数据结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;跳跃表的查询复杂度可以接近O(logN)。
跳跃表的查询效率可以与平衡树媲美，但设计与实现却比平衡树简单得多。设计思想是通过空间换时间。通过建立多层链表，高层的链表比低层的跨度大，就可以加快查询速度。&lt;/p&gt;
&lt;p&gt;当有序集合中元素数量很多，或者元素的成员是较长的字符串，就会使用跳跃表作为底层实现。&lt;/p&gt;
&lt;h2&gt;哈希表&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 字典&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;dict&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;dictType&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;privdata&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;dictht&lt;/span&gt; &lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;rehashidx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// hashtable&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;dictht&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;dictEntry&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;unsignd&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;sizemask&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;used&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;dictht&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// 哈希表节点&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;dictEntry&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;u64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int64_t&lt;/span&gt; &lt;span class="n"&gt;s64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;dictEntry&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;dictEntry&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;链地址法来解决冲突，将新节点添加到链表的表头位置。&lt;/p&gt;
&lt;p&gt;渐进式哈希，两个哈希表，每次对字典进行添加，删除，查找或更新操作，会将rehashidx索引上的键值对rehash到&lt;code&gt;ht[1]&lt;/code&gt;。当所有键值对都rehash到&lt;code&gt;ht[1]&lt;/code&gt;，
设置rehashidx=-1，rehash操作完成。分而治之，避免集中式处理对redis性能影响太大。rehash期间，查找会在两个哈希表查找，新增的键值会直接添加到&lt;code&gt;ht[1]&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;整数集合&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;intset&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int8_t&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;[];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;intset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整数集合的每个元素都是contents数组的一个数据项，各个项在数据中按值的大小&lt;strong&gt;从小到大&lt;/strong&gt;有序地排列，并且数组中&lt;strong&gt;不包含任何重复项&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;contents数组的真正类型取决于encoding属性的值。 encoding为INTSET_ENC_INT16，整数集合底层实现为int16_t类型的数组，集合保存的都是int16_t类型的整数值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;升级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加新元素，并且新元素的类型比整数集合现有所有元素都要长时。&lt;/p&gt;
&lt;p&gt;升级要做的是，根据新类型的长度，以及元素的数量，对底层数组进行空间重分配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;降级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不支持降级。一旦对数组进行了升级，编码就会一直保持升级后的状态。&lt;/p&gt;
&lt;p&gt;采用整数集合存储提升了灵活性，也尽可能地节约内存&lt;/p&gt;
&lt;h2&gt;压缩列表&lt;/h2&gt;
&lt;p&gt;压缩列表是为了节约内存而开发，由一系列特殊编码的&lt;strong&gt;连续内存块&lt;/strong&gt;组成。每个节点可以保存一个字符数组或者一个整数值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;zlbytes&lt;/span&gt; &lt;span class="n"&gt;zltail&lt;/span&gt; &lt;span class="n"&gt;zllen&lt;/span&gt; &lt;span class="n"&gt;entry1&lt;/span&gt; &lt;span class="n"&gt;entry2&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;entryN&lt;/span&gt; &lt;span class="n"&gt;zlend&lt;/span&gt;
&lt;span class="n"&gt;previous_entry_length&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;了解下连锁更新。&lt;/p&gt;
&lt;h2&gt;对象&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;redisObject&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="nl"&gt;type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="nl"&gt;encoding&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;robj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;类型常量&lt;/th&gt;
&lt;th&gt;对象名称&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_STRING&lt;/td&gt;
&lt;td&gt;字符串对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_LIST&lt;/td&gt;
&lt;td&gt;列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_HASH&lt;/td&gt;
&lt;td&gt;哈希&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_SET&lt;/td&gt;
&lt;td&gt;集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_ZSET&lt;/td&gt;
&lt;td&gt;有序集合&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用TYPE命令查看对象的类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;rpush alist &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="m"&gt;5&lt;/span&gt;
TYPE alist  &lt;span class="c1"&gt;# list&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;数据类型与编码&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;编码&lt;/th&gt;
&lt;th&gt;对象&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_STRING&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_INT&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_STRING&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_EMBSTR&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_STRING&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_RAW&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_LIST&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_ZIPLIST&lt;/td&gt;
&lt;td&gt;压缩列表实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_LIST&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_LINKEDLIST&lt;/td&gt;
&lt;td&gt;使用双端链表实现的列表对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_HASH&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_ZIPLIST&lt;/td&gt;
&lt;td&gt;压缩列表实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_HASH&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_HT&lt;/td&gt;
&lt;td&gt;字典实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_SET&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_INTSET&lt;/td&gt;
&lt;td&gt;整数集合实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_SET&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_HT&lt;/td&gt;
&lt;td&gt;字典实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_ZSET&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_ZIPLIST&lt;/td&gt;
&lt;td&gt;压缩列表实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REDIS_ZSET&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_SKIPLIST&lt;/td&gt;
&lt;td&gt;使用跳跃表和字典实现的有序集合对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;底层数据结构与编码常量&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;底层数据结构&lt;/th&gt;
&lt;th&gt;编码常量&lt;/th&gt;
&lt;th&gt;命令输出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;整数&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_INT&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;embstr编码的简单动态字符串SDS&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_EMBSTR&lt;/td&gt;
&lt;td&gt;embstr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;简单动态字符串SDS&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_RAW&lt;/td&gt;
&lt;td&gt;raw&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字典&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_HT&lt;/td&gt;
&lt;td&gt;hashtable&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;双端链表&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_LINKEDLIST&lt;/td&gt;
&lt;td&gt;linkedlist&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;压缩列表&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_ZIPLIST&lt;/td&gt;
&lt;td&gt;ziplist&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;整数集合&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_INTSET&lt;/td&gt;
&lt;td&gt;intset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;跳跃表和字典&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_SKIPLIST&lt;/td&gt;
&lt;td&gt;skiplist&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用OBJECT ENCODING查看对象的编码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt; msg &lt;span class="s2"&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;
OBJECT ENCODING msg
&lt;/pre&gt;&lt;/div&gt;
</description><author>zqiang33@163.com (君祁)</author><guid isPermaLink="true">/Blog-With-GitHub-Boilerplate/archives/redis/</guid><pubDate>Thu, 17 Jun 2021 17:15:16 +0806</pubDate></item><item><title>聊聊Java8的函数式编程</title><link>/Blog-With-GitHub-Boilerplate/archives/java_function_program/</link><description>&lt;p&gt;函数式编程是Java8的一大特色。&lt;/p&gt;
&lt;h2&gt;Stream&lt;/h2&gt;
</description><author>zqiang33@163.com (君祁)</author><guid isPermaLink="true">/Blog-With-GitHub-Boilerplate/archives/java_function_program/</guid><pubDate>Fri, 18 Jun 2021 10:30:05 +0806</pubDate></item><item><title>谈谈数据库的索引</title><link>/Blog-With-GitHub-Boilerplate/archives/mysql_index/</link><description>&lt;h2&gt;索引有哪几种实现的方式？&lt;/h2&gt;
&lt;p&gt;索引的实现方式有很多种，常见的三种数据结构是哈希表、有序数组和搜索树。&lt;/p&gt;
&lt;p&gt;哈希表的查询复杂度可以接近O(1)，适合做等值查询，但做范围查询要做全表扫描，效率非常低。&lt;/p&gt;
&lt;p&gt;有序数组做等值查询和范围查询效率都很高，但更新数据的成本很高。&lt;/p&gt;
&lt;p&gt;平衡二叉搜索树的查询和更新时间复杂度都是O(logN)。但二叉树的高度可能很高，查询时需要访问多个数据块，就会有多次读取磁盘的操作。为了让一个查询尽量少地读磁盘， 
应该使用N叉树（多路查找树），使索引树的高度尽量少。一般树根的数据块会加载到内存，一个高度为4的N叉树只需要3次访问磁盘。N叉树由于在读写上的性能优点，
以及适配磁盘的访问模式，被广泛应用在数据库引擎中。&lt;/p&gt;
</description><author>zqiang33@163.com (君祁)</author><guid isPermaLink="true">/Blog-With-GitHub-Boilerplate/archives/mysql_index/</guid><pubDate>Fri, 18 Jun 2021 10:45:11 +0806</pubDate></item><item><title>MySQL高可用</title><link>/Blog-With-GitHub-Boilerplate/archives/mysql_ha/</link><description>&lt;h2&gt;主从复制的过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;master开启binlog功能。&lt;/li&gt;
&lt;li&gt;master开启io线程，slave开启io线程，sql线程。&lt;/li&gt;
&lt;li&gt;master通过io线程将binlog日志发送到slave，slave通过io线程接收binlog数据，将其写入relay-log（中继日志）。&lt;/li&gt;
&lt;li&gt;slave的sql线程实时监测relay-log的内容是否有更新，如果有更新，将里面的sql语句重新执行生成相应的数据。&lt;/li&gt;
&lt;/ol&gt;
</description><author>zqiang33@163.com (君祁)</author><guid isPermaLink="true">/Blog-With-GitHub-Boilerplate/archives/mysql_ha/</guid><pubDate>Fri, 18 Jun 2021 16:00:26 +0806</pubDate></item><item><title>二叉树的前中后序遍历</title><link>/Blog-With-GitHub-Boilerplate/archives/binary_tree/</link><description>&lt;h2&gt;递归法&lt;/h2&gt;
&lt;p&gt;递归算法的三个要素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定递归函数的参数和返回值&lt;/li&gt;
&lt;li&gt;确定终止条件&lt;/li&gt;
&lt;li&gt;确定单层递归的逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Definition for a binary tree node.&lt;/span&gt;
&lt;span class="c1"&gt;# class TreeNode(object):&lt;/span&gt;
&lt;span class="c1"&gt;#     def __init__(self, val=0, left=None, right=None):&lt;/span&gt;
&lt;span class="c1"&gt;#         self.val = val&lt;/span&gt;
&lt;span class="c1"&gt;#         self.left = left&lt;/span&gt;
&lt;span class="c1"&gt;#         self.right = right&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;postorderTraversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        :type root: TreeNode&lt;/span&gt;
&lt;span class="sd"&gt;        :rtype: List[int]&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;


    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;

        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;迭代法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;中序遍历的迭代写法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;inorderTraversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
      &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;      :type root: TreeNode&lt;/span&gt;
&lt;span class="sd"&gt;      :rtype: List[int]&lt;/span&gt;
&lt;span class="sd"&gt;      &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

      &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;

      &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
              &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;
          &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
              &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
              &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;

      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前序遍历的迭代写法
思路：借助栈，弹出根，将根的右节点和左节点入栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;后序遍历的迭代写法
思路：前序遍历是根-&amp;gt;左-&amp;gt;右，根-&amp;gt;右-&amp;gt;左也可以认为是一种前序遍历，而后序遍历左-&amp;gt;右-&amp;gt;根恰好是根-&amp;gt;右-&amp;gt;左的逆序！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;迭代法的统一写法&lt;/h2&gt;
&lt;p&gt;中序遍历的迭代写法难写，本质原因在于节点的访问顺序和处理顺序不一致！&lt;/p&gt;
&lt;p&gt;如何解决呢？可以采用标记法，将访问的节点放入栈中，将处理的节点也放入栈中但要做标记。就是在节点放入栈后，紧接着放入一个空指针作为标记。在出栈时，
遇到空指针节点，就连续弹两次栈，将空指针下面的待处理节点直接输出。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Definition for a binary tree node.&lt;/span&gt;
&lt;span class="c1"&gt;# class TreeNode(object):&lt;/span&gt;
&lt;span class="c1"&gt;#     def __init__(self, val=0, left=None, right=None):&lt;/span&gt;
&lt;span class="c1"&gt;#         self.val = val&lt;/span&gt;
&lt;span class="c1"&gt;#         self.left = left&lt;/span&gt;
&lt;span class="c1"&gt;#         self.right = right&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;postorderTraversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        :type root: TreeNode&lt;/span&gt;
&lt;span class="sd"&gt;        :rtype: List[int]&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
                &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description><author>zqiang33@163.com (君祁)</author><guid isPermaLink="true">/Blog-With-GitHub-Boilerplate/archives/binary_tree/</guid><pubDate>Thu, 24 Jun 2021 00:16:53 +0806</pubDate></item><item><title>redis高可用</title><link>/Blog-With-GitHub-Boilerplate/archives/redis_ha/</link><description>&lt;h2&gt;过期删除策略&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://zhuanlan.zhihu.com/p/139423463"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定时删除，对内存友好，对cpu不友好&lt;/li&gt;
&lt;li&gt;惰性删除，对cpu友好，对内存不友好&lt;/li&gt;
&lt;li&gt;定期删除，折中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从服务器不会触发键过期，而是会等待主节点触发键过期。主节点键过期时，会同步del命令给所有的从节点。
从节点不处理过期键，但也不会返回已过期的数据，会通过独有的逻辑来标记一个键已经过期。&lt;/p&gt;
&lt;h2&gt;主从模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主从复制的过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主节点(master)开启一个子进程，生成rdb快照文件，同时将新的命令写到缓冲区&lt;/li&gt;
&lt;li&gt;向从节点(slave)发送rdb快照文件&lt;/li&gt;
&lt;li&gt;从节点收到rdb文件后，加载数据到内存&lt;/li&gt;
&lt;li&gt;主节点再将缓冲区命令发到从节点，加载后与主节点达到一致状态&lt;/li&gt;
&lt;li&gt;之后主节点每收到一个新的写命令，都会同步给从节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主从复制开始时，副本从主机全量同步数据，发送psync命令，主机执行bgsave，在后台开启一个子进程产生rdb文件，同时将后面新的写命令写到一个缓冲区，然后把rdb文件发送给从机，从机收到后load到内存，这个步骤完成后主机再将缓冲区的数据发给从机，再之后主机收到新的写命令，都会发给从机&lt;/p&gt;
&lt;p&gt;master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。&lt;/p&gt;
&lt;p&gt;增量同步条件：主机会维护一个复制积压缓冲区，如果从节点缺失的数据在复制积压缓冲区内，可以执行增量同步，否则执行全量同步。&lt;/p&gt;
&lt;p&gt;复制积压缓冲区是一个固定长度的先进先出队列，默认大小为1M。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主库执行全量备份会造成毫秒或秒级的卡顿&lt;/li&gt;
&lt;li&gt;COW机制，极端情况下主库内存溢出，程序异常退出或宕机&lt;/li&gt;
&lt;li&gt;发送数GB大小的备份文件导致服务器出口带宽暴增，阻塞请求。&lt;/li&gt;
&lt;li&gt;需要人为手工操作，需要通知业务方做变更配置，整个过程需要人为干预，较为烦琐&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在主-从模式里，如果主服务器宕机了，虽然可以由从机来代替主机继续服务，但这需要人工把从机切换成主机，需要人工干预，还会造成一段时间服务不可用。&lt;/p&gt;
&lt;h2&gt;sentinel&lt;/h2&gt;
&lt;p&gt;Sentinel是Redis的高可用性解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;故障转移的过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个sentinel根据心跳响应超时判断主节点是否主观下线，根据配置判定是否客观下线。sentinel判定下线的标准是写在配置里的，包括多久超时，其他sentinel认为下线的数量。&lt;/li&gt;
&lt;li&gt;选举领头sentinel，在每个纪元周期，每个sentinel都可以发送广播让其他sentinel设置自己为领头sentinel；每个sentinel有一次机会设置另一个sentinel为leader；
当某个sentinel获得了半数以上的选票，就成为leader，并发送广播告诉其他sentinel，选举阶段结束。&lt;/li&gt;
&lt;li&gt;领头sentinel选择一台从服务器，将其升级为主服务器。选取的标准有几个。&lt;/li&gt;
&lt;li&gt;向其他从服务器发送命令，让它们复制新的主服务器&lt;/li&gt;
&lt;li&gt;当旧的主服务器重新连线后，将成为新的主服务器的从服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选取从服务器升级为主服务器的标准：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除所有下线或断线的从服务器&lt;/li&gt;
&lt;li&gt;删除最近5秒没有回复info命令的从服务器&lt;/li&gt;
&lt;li&gt;删除与主服务器断开超过一定时间的从服务器，保证数据是相对较新的&lt;/li&gt;
&lt;li&gt;选择优先级最高的&lt;/li&gt;
&lt;li&gt;选择复制偏移量最大的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;sentinel的启动过程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个sentinel都与主服务器建立命令连接和订阅连接。命令连接可以发送info命令，发送publish命令，订阅连接可以接收hello频道的信息&lt;/li&gt;
&lt;li&gt;与主服务器建立连接后，可以向主服务器发送info命令，可以得到从服务器的信息。sentinel就可以无需用户提供从服务器的信息，可以通过主服务器发现从服务器&lt;/li&gt;
&lt;li&gt;发现从服务器后，创建与从服务器的命令连接和订阅连接，也可以向从服务器发送info命令了&lt;/li&gt;
&lt;li&gt;sentinel通过hello频道的信息可以自动发现其他sentinel，相互之间建立命令连接，不建议订阅连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Redis Cluster&lt;/h2&gt;
&lt;p&gt;Redis Cluster是Redis提供的&lt;strong&gt;分布式集群&lt;/strong&gt;解决方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。&lt;/p&gt;
&lt;p&gt;通过Gossip协议进行通信。&lt;/p&gt;
&lt;p&gt;最小配置6个节点以上（3主3从），主节点提供读写操作，从节点作为备用节点，不提供服务，只作为故障转移使用。节点只使用0号数据库&lt;/p&gt;
&lt;p&gt;关键词：节点、槽指派、命令执行、重新分片、转向、故障转移、消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;故障转移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;集群中的每个节点都会定期地向其他节点发送ping消息，以此来检测对方是否在线。如果接收ping消息的节点没有在规定的时间之内回复pong，就会被标记为&lt;strong&gt;疑似下线&lt;/strong&gt;。节点的状态包括：在线，疑似下线，已下线。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果集群里半数以上的负责处理槽的主节点将某个主节点报告为疑似下线，则该节点将被标记为&lt;strong&gt;已下线&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;第一个标记节点为已下线的主节点将向集群广播一条消息，所有收到消息的节点也会立即标记该节点已下线。&lt;/li&gt;
&lt;li&gt;从已下线的主节点下选中一个从节点，使其成为新的主节点。&lt;/li&gt;
&lt;li&gt;新的主节点接管所有旧的主节点的槽，指派给自己。&lt;/li&gt;
&lt;li&gt;向集群广播一条消息，告诉其他节点自己已成为新的主节点，并接管了所有的槽。&lt;/li&gt;
&lt;li&gt;新的主节点开始接收命令和处理自己负责的槽，故障转移完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;选举新的主节点的过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的主节点有投票权，从节点没有投票权&lt;/li&gt;
&lt;li&gt;在某个主节点已下线后，其下的从节点会向集群广播一条消息，要求收到消息的主节点向自己投票。&lt;/li&gt;
&lt;li&gt;每个在线的主节点都有一次投票机会，会选择最先向自己要求投票的从节点。&lt;/li&gt;
&lt;li&gt;当某个从节点获得了半数以上的投票，则选举成功；否则，任何一个从节点都没有获得足够多的选票，会在新的纪元周期发起选举。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;读写分离的讨论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官方默认cluster不进行读写分离。在cluster架构下，默认的，一般redis-master用于接收读写，而redis-slave则用于备份，当有请求是向slave发起时，会直接重定向到对应key的master来处理。&lt;/p&gt;
&lt;p&gt;可通过readonly命令，将slave设置成可读，然后通过slave获取相关的key，达到读写分离。&lt;/p&gt;
&lt;p&gt;不过，通过对master进行水平扩展就可以了，扩容master，跟之前扩容slave并进行读写分离，效果是一样的或者更好。&lt;/p&gt;
</description><author>zqiang33@163.com (君祁)</author><guid isPermaLink="true">/Blog-With-GitHub-Boilerplate/archives/redis_ha/</guid><pubDate>Thu, 24 Jun 2021 01:00:23 +0806</pubDate></item></channel></rss>