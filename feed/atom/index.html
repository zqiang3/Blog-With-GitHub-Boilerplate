<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><id>/Blog-With-GitHub-Boilerplate/</id><title>君祁的技术博客</title><updated>2021-07-15T09:09:46.267661+08:06</updated><author><name>君祁</name><email>zqiang33@163.com</email></author><link href="/Blog-With-GitHub-Boilerplate/" rel="alternate"/><generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator><logo>/Blog-With-GitHub-Boilerplate/logo.png</logo><subtitle>只有一种英雄主义，就是看清生活真相之后依然热爱生活。</subtitle><entry><id>/Blog-With-GitHub-Boilerplate/archives/mysql_ha/</id><title>MySQL高可用</title><updated>2021-07-15T09:09:46.267971+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;主从复制的过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;master开启binlog功能。&lt;/li&gt;
&lt;li&gt;master开启io线程，slave开启io线程，sql线程。&lt;/li&gt;
&lt;li&gt;master通过io线程将binlog日志发送到slave，slave通过io线程接收binlog数据，将其写入relay-log（中继日志）。&lt;/li&gt;
&lt;li&gt;slave的sql线程实时监测relay-log的内容是否有更新，如果有更新，将里面的sql语句重新执行生成相应的数据。&lt;/li&gt;
&lt;/ol&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/mysql_ha/" rel="alternate"/><published>2021-06-18T16:00:26+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/binary_tree/</id><title>二叉树的前中后序遍历</title><updated>2021-07-15T09:09:46.267947+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;递归法&lt;/h2&gt;
&lt;p&gt;递归算法的三个要素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定递归函数的参数和返回值&lt;/li&gt;
&lt;li&gt;确定终止条件&lt;/li&gt;
&lt;li&gt;确定单层递归的逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Definition for a binary tree node.&lt;/span&gt;
&lt;span class="c1"&gt;# class TreeNode(object):&lt;/span&gt;
&lt;span class="c1"&gt;#     def __init__(self, val=0, left=None, right=None):&lt;/span&gt;
&lt;span class="c1"&gt;#         self.val = val&lt;/span&gt;
&lt;span class="c1"&gt;#         self.left = left&lt;/span&gt;
&lt;span class="c1"&gt;#         self.right = right&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;postorderTraversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        :type root: TreeNode&lt;/span&gt;
&lt;span class="sd"&gt;        :rtype: List[int]&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;


    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;

        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;迭代法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;中序遍历的迭代写法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;inorderTraversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
      &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;      :type root: TreeNode&lt;/span&gt;
&lt;span class="sd"&gt;      :rtype: List[int]&lt;/span&gt;
&lt;span class="sd"&gt;      &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

      &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;

      &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
              &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;
          &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
              &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
              &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;

      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前序遍历的迭代写法
思路：借助栈，弹出根，将根的右节点和左节点入栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;后序遍历的迭代写法
思路：前序遍历是根-&amp;gt;左-&amp;gt;右，根-&amp;gt;右-&amp;gt;左也可以认为是一种前序遍历，而后序遍历左-&amp;gt;右-&amp;gt;根恰好是根-&amp;gt;右-&amp;gt;左的逆序！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;迭代法的统一写法&lt;/h2&gt;
&lt;p&gt;中序遍历的迭代写法难写，本质原因在于节点的访问顺序和处理顺序不一致！&lt;/p&gt;
&lt;p&gt;如何解决呢？可以采用标记法，将访问的节点放入栈中，将处理的节点也放入栈中但要做标记。就是在节点放入栈后，紧接着放入一个空指针作为标记。在出栈时，
遇到空指针节点，就连续弹两次栈，将空指针下面的待处理节点直接输出。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Definition for a binary tree node.&lt;/span&gt;
&lt;span class="c1"&gt;# class TreeNode(object):&lt;/span&gt;
&lt;span class="c1"&gt;#     def __init__(self, val=0, left=None, right=None):&lt;/span&gt;
&lt;span class="c1"&gt;#         self.val = val&lt;/span&gt;
&lt;span class="c1"&gt;#         self.left = left&lt;/span&gt;
&lt;span class="c1"&gt;#         self.right = right&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;postorderTraversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        :type root: TreeNode&lt;/span&gt;
&lt;span class="sd"&gt;        :rtype: List[int]&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
                &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/binary_tree/" rel="alternate"/><published>2021-06-24T00:16:53+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/redis_ha/</id><title>redis高可用</title><updated>2021-07-15T09:09:46.267924+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;过期删除策略&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://zhuanlan.zhihu.com/p/139423463"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定时删除，对内存友好，对cpu不友好&lt;/li&gt;
&lt;li&gt;惰性删除，对cpu友好，对内存不友好&lt;/li&gt;
&lt;li&gt;定期删除，折中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从服务器不会触发键过期，而是会等待主节点触发键过期。主节点键过期时，会同步del命令给所有的从节点。
从节点不处理过期键，但也不会返回已过期的数据，会通过独有的逻辑来标记一个键已经过期。&lt;/p&gt;
&lt;h2&gt;主从模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主从复制的过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主节点(master)开启一个子进程，生成rdb快照文件，同时将新的命令写到缓冲区&lt;/li&gt;
&lt;li&gt;向从节点(slave)发送rdb快照文件&lt;/li&gt;
&lt;li&gt;从节点收到rdb文件后，加载数据到内存&lt;/li&gt;
&lt;li&gt;主节点再将缓冲区命令发到从节点，加载后与主节点达到一致状态&lt;/li&gt;
&lt;li&gt;之后主节点每收到一个新的写命令，都会同步给从节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主从复制开始时，副本从主机全量同步数据，发送psync命令，主机执行bgsave，在后台开启一个子进程产生rdb文件，同时将后面新的写命令写到一个缓冲区，然后把rdb文件发送给从机，从机收到后load到内存，这个步骤完成后主机再将缓冲区的数据发给从机，再之后主机收到新的写命令，都会发给从机&lt;/p&gt;
&lt;p&gt;master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。&lt;/p&gt;
&lt;p&gt;增量同步条件：主机会维护一个复制积压缓冲区，如果从节点缺失的数据在复制积压缓冲区内，可以执行增量同步，否则执行全量同步。&lt;/p&gt;
&lt;p&gt;复制积压缓冲区是一个固定长度的先进先出队列，默认大小为1M。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主库执行全量备份会造成毫秒或秒级的卡顿&lt;/li&gt;
&lt;li&gt;COW机制，极端情况下主库内存溢出，程序异常退出或宕机&lt;/li&gt;
&lt;li&gt;发送数GB大小的备份文件导致服务器出口带宽暴增，阻塞请求。&lt;/li&gt;
&lt;li&gt;需要人为手工操作，需要通知业务方做变更配置，整个过程需要人为干预，较为烦琐&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在主-从模式里，如果主服务器宕机了，虽然可以由从机来代替主机继续服务，但这需要人工把从机切换成主机，需要人工干预，还会造成一段时间服务不可用。&lt;/p&gt;
&lt;h2&gt;sentinel&lt;/h2&gt;
&lt;p&gt;Sentinel是Redis的高可用性解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;故障转移的过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个sentinel根据心跳响应超时判断主节点是否主观下线，根据配置判定是否客观下线。sentinel判定下线的标准是写在配置里的，包括多久超时，其他sentinel认为下线的数量。&lt;/li&gt;
&lt;li&gt;选举领头sentinel，在每个纪元周期，每个sentinel都可以发送广播让其他sentinel设置自己为领头sentinel；每个sentinel有一次机会设置另一个sentinel为leader；
当某个sentinel获得了半数以上的选票，就成为leader，并发送广播告诉其他sentinel，选举阶段结束。&lt;/li&gt;
&lt;li&gt;领头sentinel选择一台从服务器，将其升级为主服务器。选取的标准有几个。&lt;/li&gt;
&lt;li&gt;向其他从服务器发送命令，让它们复制新的主服务器&lt;/li&gt;
&lt;li&gt;当旧的主服务器重新连线后，将成为新的主服务器的从服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选取从服务器升级为主服务器的标准：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除所有下线或断线的从服务器&lt;/li&gt;
&lt;li&gt;删除最近5秒没有回复info命令的从服务器&lt;/li&gt;
&lt;li&gt;删除与主服务器断开超过一定时间的从服务器，保证数据是相对较新的&lt;/li&gt;
&lt;li&gt;选择优先级最高的&lt;/li&gt;
&lt;li&gt;选择复制偏移量最大的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;sentinel的启动过程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个sentinel都与主服务器建立命令连接和订阅连接。命令连接可以发送info命令，发送publish命令，订阅连接可以接收hello频道的信息&lt;/li&gt;
&lt;li&gt;与主服务器建立连接后，可以向主服务器发送info命令，可以得到从服务器的信息。sentinel就可以无需用户提供从服务器的信息，可以通过主服务器发现从服务器&lt;/li&gt;
&lt;li&gt;发现从服务器后，创建与从服务器的命令连接和订阅连接，也可以向从服务器发送info命令了&lt;/li&gt;
&lt;li&gt;sentinel通过hello频道的信息可以自动发现其他sentinel，相互之间建立命令连接，不建议订阅连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Redis Cluster&lt;/h2&gt;
&lt;p&gt;Redis Cluster是Redis提供的&lt;strong&gt;分布式集群&lt;/strong&gt;解决方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。&lt;/p&gt;
&lt;p&gt;通过Gossip协议进行通信。&lt;/p&gt;
&lt;p&gt;最小配置6个节点以上（3主3从），主节点提供读写操作，从节点作为备用节点，不提供服务，只作为故障转移使用。节点只使用0号数据库&lt;/p&gt;
&lt;p&gt;关键词：节点、槽指派、命令执行、重新分片、转向、故障转移、消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;故障转移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;集群中的每个节点都会定期地向其他节点发送ping消息，以此来检测对方是否在线。如果接收ping消息的节点没有在规定的时间之内回复pong，就会被标记为&lt;strong&gt;疑似下线&lt;/strong&gt;。节点的状态包括：在线，疑似下线，已下线。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果集群里半数以上的负责处理槽的主节点将某个主节点报告为疑似下线，则该节点将被标记为&lt;strong&gt;已下线&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;第一个标记节点为已下线的主节点将向集群广播一条消息，所有收到消息的节点也会立即标记该节点已下线。&lt;/li&gt;
&lt;li&gt;从已下线的主节点下选中一个从节点，使其成为新的主节点。&lt;/li&gt;
&lt;li&gt;新的主节点接管所有旧的主节点的槽，指派给自己。&lt;/li&gt;
&lt;li&gt;向集群广播一条消息，告诉其他节点自己已成为新的主节点，并接管了所有的槽。&lt;/li&gt;
&lt;li&gt;新的主节点开始接收命令和处理自己负责的槽，故障转移完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;选举新的主节点的过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的主节点有投票权，从节点没有投票权&lt;/li&gt;
&lt;li&gt;在某个主节点已下线后，其下的从节点会向集群广播一条消息，要求收到消息的主节点向自己投票。&lt;/li&gt;
&lt;li&gt;每个在线的主节点都有一次投票机会，会选择最先向自己要求投票的从节点。&lt;/li&gt;
&lt;li&gt;当某个从节点获得了半数以上的投票，则选举成功；否则，任何一个从节点都没有获得足够多的选票，会在新的纪元周期发起选举。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;读写分离的讨论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官方默认cluster不进行读写分离。在cluster架构下，默认的，一般redis-master用于接收读写，而redis-slave则用于备份，当有请求是向slave发起时，会直接重定向到对应key的master来处理。&lt;/p&gt;
&lt;p&gt;可通过readonly命令，将slave设置成可读，然后通过slave获取相关的key，达到读写分离。&lt;/p&gt;
&lt;p&gt;不过，通过对master进行水平扩展就可以了，扩容master，跟之前扩容slave并进行读写分离，效果是一样的或者更好。&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/redis_ha/" rel="alternate"/><published>2021-06-24T01:00:23+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/consistency/</id><title>一致性问题</title><updated>2021-07-15T09:09:46.267901+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;一致性问题的产生&lt;/h2&gt;
&lt;p&gt;同一份数据有多份副本，我们面临这样的问题，如何在它们之间同步数据，以便让客户端对数据有一致性的视图。 CAP理论对一致性的定义：每次读请求都能收到最新的数据或者是错误。&lt;/p&gt;
&lt;h2&gt;弱一致性&lt;/h2&gt;
&lt;p&gt;写入数据后，客户端访问可能看不到最新写入的数据，系统优先保证响应速度。弱一致性适合音视频聊天，实时多人游戏等场景。&lt;/p&gt;
&lt;h2&gt;最终一致性&lt;/h2&gt;
&lt;p&gt;写入数据后，客户端访问最终能看到写入的新数据（可能延迟几毫秒），数据被异步复制。 最终一致性在高可用系统中效果不错。&lt;/p&gt;
&lt;h2&gt;强一致性&lt;/h2&gt;
&lt;p&gt;写入数据后，客户端访问到的一定是最新数据。数据被同步复制。 强一致性适合需要事务的场景。&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/consistency/" rel="alternate"/><published>2021-07-14T19:45:39+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/blog_template/</id><title>blog_template</title><updated>2021-07-15T09:09:46.267877+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hexo.io/"&gt;hexo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/blog_template/" rel="alternate"/><published>2021-07-14T19:47:55+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/algorithm_summary/</id><title>算法套路总结</title><updated>2021-07-15T09:09:46.267854+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;二分查找&lt;/h2&gt;
&lt;h2&gt;双指针&lt;/h2&gt;
&lt;p&gt;双指针技巧分为两类，一类是快慢指针，一类是左右指针。&lt;/p&gt;
&lt;h2&gt;滑动窗口&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;size&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;valid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;window的数据类型可以视具体情况而定，比如上述题目都使用哈希表充当计数器，也可以使用一个数组实现同样的效果。&lt;/p&gt;
&lt;p&gt;valid条件是难点，视具体题目而定。&lt;/p&gt;
&lt;h2&gt;哈希表&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://leetcode-cn.com/problems/two-sum/"&gt;TwoSum问题&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;二叉树&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%93%8D%E4%BD%9C%E9%9B%86%E9%94%A6.md"&gt;二叉树集锦&lt;/a&gt;&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/algorithm_summary/" rel="alternate"/><published>2021-07-14T19:52:25+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/ddd/</id><title>领域驱动设计</title><updated>2021-07-15T09:09:46.267829+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content/><link href="/Blog-With-GitHub-Boilerplate/archives/ddd/" rel="alternate"/><published>2021-07-14T19:56:11+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/docker_commands/</id><title>docker commands</title><updated>2021-07-15T09:09:46.267804+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;docker commands&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;attach: Attach local standard input, output, and error streams to a running container&lt;/li&gt;
&lt;li&gt;build: Build an image from a Dockerfile&lt;/li&gt;
&lt;li&gt;commit: Create a new image from a container's changes&lt;/li&gt;
&lt;li&gt;create: Create a new container&lt;/li&gt;
&lt;li&gt;diff: Inspect changes to files or directories on a container's filesystem&lt;/li&gt;
&lt;li&gt;exec: Run a command in a running container&lt;/li&gt;
&lt;li&gt;images: List images&lt;/li&gt;
&lt;li&gt;info: Display system-wide information&lt;/li&gt;
&lt;li&gt;inspect: Return low-level information on Docker objects&lt;/li&gt;
&lt;li&gt;kill: Kill one or more running containers&lt;/li&gt;
&lt;li&gt;login: Log in to a Docker registry&lt;/li&gt;
&lt;li&gt;logout: Log out from a Docker registry&lt;/li&gt;
&lt;li&gt;logs: Fetch the logs of a container&lt;/li&gt;
&lt;li&gt;pause: Pause all processes within one or more containers&lt;/li&gt;
&lt;li&gt;ps: List containers&lt;/li&gt;
&lt;li&gt;pull: Pull an image or a repository from a registry&lt;/li&gt;
&lt;li&gt;push: Push an image or a repository to a registry&lt;/li&gt;
&lt;li&gt;rename: Rename a container&lt;/li&gt;
&lt;li&gt;restart: Restart one or more containers&lt;/li&gt;
&lt;li&gt;rm: Remove one or more containers&lt;/li&gt;
&lt;li&gt;rmi: Remove one or more images&lt;/li&gt;
&lt;li&gt;run: Run a command in a new container&lt;/li&gt;
&lt;li&gt;search: Search the Docker Hub for images&lt;/li&gt;
&lt;li&gt;start: Start one or more stopped containers&lt;/li&gt;
&lt;li&gt;stats: Display a live stream of container(s) resource usage statistics&lt;/li&gt;
&lt;li&gt;stop: Stop one or more running containers&lt;/li&gt;
&lt;li&gt;tag: Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE&lt;/li&gt;
&lt;li&gt;top: Display the running processes of a container&lt;/li&gt;
&lt;li&gt;unpause: Unpause all processes within one or more containers&lt;/li&gt;
&lt;li&gt;update: Update configuration of one or more containers&lt;/li&gt;
&lt;li&gt;version: Show the Docker version information&lt;/li&gt;
&lt;li&gt;wait: Block until one or more containers stop, then print their exit codes&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;docker run&lt;/h2&gt;
&lt;p&gt;使用docker run的时候，通过-v HOST_DIR:CONTAINER_DIR参数来指定数据卷使用的主机目录，这个做法一般被称为“绑定挂载”。
主机目录指运行docker引擎的机器。如果是远程连接到docker服务的话，那么远端的计算机必须已经存在该路径。&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/docker_commands/" rel="alternate"/><published>2021-07-14T19:57:36+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/docker_resource/</id><title>docker资源</title><updated>2021-07-15T09:09:46.267775+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;ul&gt;
&lt;li&gt;Docker官方主页(&lt;a href="http://www.docker.com/)。"&gt;http://www.docker.com/)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker Hub(&lt;a href="http://hub.docker.com)。"&gt;http://hub.docker.com)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker官方博客(&lt;a href="http://blog.docker.com/)。"&gt;http://blog.docker.com/)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker官方文档(&lt;a href="http://docs.docker.com/)。"&gt;http://docs.docker.com/)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker快速入门指南(&lt;a href="https://docs.docker.com/get-started/overview/)。"&gt;https://docs.docker.com/get-started/overview/)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker的GitHub 源代码(&lt;a href="https://github.com/docker/docker)。"&gt;https://github.com/docker/docker)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker Forge(&lt;a href="https://github.com/dockerforge):收集了各种Docker工具、组件和服务。"&gt;https://github.com/dockerforge):收集了各种Docker工具、组件和服务。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker邮件列表(&lt;a href="https://groups.google.com/forum/#!forum/docker-user)。"&gt;https://groups.google.com/forum/#!forum/docker-user)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker的IRC 频道(irc.freenode.net)。&lt;/li&gt;
&lt;li&gt;Docker的Twitter主页(&lt;a href="http://twitter.com/docker)。"&gt;http://twitter.com/docker)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker的StackOverflow问答主页(&lt;a href="http://stackoverflow.com/search?q=docker)。"&gt;http://stackoverflow.com/search?q=docker)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker官网(&lt;a href="http://www.docker.com/)。"&gt;http://www.docker.com/)。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;孙洪亮的 Docker源码分析&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.zhihu.com/pub/book/119564848"&gt;Docker开发指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.zhihu.com/pub/reader/119943940/chapter/1283922533264543744"&gt;Kubernetes权威指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://martinfowler.com/microservices/"&gt;微服务资源指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;微服务设计 Sam Newman&lt;/li&gt;
&lt;/ul&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/docker_resource/" rel="alternate"/><published>2021-07-14T20:01:42+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/health_habbit/</id><title>健康习惯</title><updated>2021-07-15T09:09:46.267724+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;p&gt;【起居有常，饮食有度，远离妄念】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证充足的睡眠。最好是【早睡早起】，比如：11点之前睡，7点起床。&lt;/li&gt;
&lt;li&gt;饮水的【5要】和【5不要】。晨起喝温水，小口喝水，工作时保持喝水，身体不适多喝水，饭前饭后喝水(尽量不在吃饭的时候喝水)。&lt;/li&gt;
&lt;li&gt;生活有规律，合理安排每一天的工作、生活、娱乐、学习。&lt;/li&gt;
&lt;li&gt;避免久坐！！！&lt;/li&gt;
&lt;li&gt;坚持锻炼。&lt;/li&gt;
&lt;li&gt;定期体检。&lt;/li&gt;
&lt;li&gt;注意牙齿健康。饭后及时漱口，晨起喝睡前记得刷牙，必要时借助牙线进行清洁，定期更换牙刷。每半年到一年洗一次牙。&lt;/li&gt;
&lt;li&gt;均衡营养、合理运动、优质睡眠、缓解压力、积极心态。&lt;/li&gt;
&lt;li&gt;注意清洁和保湿，做好这两件事，就足够解决很多皮肤问题。&lt;/li&gt;
&lt;li&gt;学习如何冥想。&lt;/li&gt;
&lt;li&gt;不着急，慢慢来，人生是一场马拉松，活得久的人才有可能取得最后的胜利。&lt;/li&gt;
&lt;li&gt;多抱抱你的家人、爱人、朋友，可以有效缓解压力。&lt;/li&gt;
&lt;li&gt;心存敬畏。敬规律，敬天地，敬良心，敬道德。有所为有所不为，道德底线不能突破。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://ixyzero.com/blog/archives/4874.html"&gt;链接&lt;/a&gt;&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/health_habbit/" rel="alternate"/><published>2021-07-15T17:07:00+08:06</published></entry></feed>