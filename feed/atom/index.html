<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><id>/Blog-With-GitHub-Boilerplate/</id><title>君祁的技术博客</title><updated>2022-09-09T06:20:01.678251+08:06</updated><author><name>君祁</name><email>zqiang33@163.com</email></author><link href="/Blog-With-GitHub-Boilerplate/" rel="alternate"/><generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator><logo>/Blog-With-GitHub-Boilerplate/logo.png</logo><subtitle>只有一种英雄主义，就是看清生活真相之后依然热爱生活。</subtitle><entry><id>/Blog-With-GitHub-Boilerplate/archives/binary_tree/</id><title>二叉树的前中后序遍历</title><updated>2022-09-09T06:20:01.678573+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;递归法&lt;/h2&gt;
&lt;p&gt;递归算法的三个要素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定递归函数的参数和返回值&lt;/li&gt;
&lt;li&gt;确定终止条件&lt;/li&gt;
&lt;li&gt;确定单层递归的逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Definition for a binary tree node.&lt;/span&gt;
&lt;span class="c1"&gt;# class TreeNode(object):&lt;/span&gt;
&lt;span class="c1"&gt;#     def __init__(self, val=0, left=None, right=None):&lt;/span&gt;
&lt;span class="c1"&gt;#         self.val = val&lt;/span&gt;
&lt;span class="c1"&gt;#         self.left = left&lt;/span&gt;
&lt;span class="c1"&gt;#         self.right = right&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;postorderTraversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        :type root: TreeNode&lt;/span&gt;
&lt;span class="sd"&gt;        :rtype: List[int]&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;


    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;

        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;迭代法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;中序遍历的迭代写法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;inorderTraversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
      &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;      :type root: TreeNode&lt;/span&gt;
&lt;span class="sd"&gt;      :rtype: List[int]&lt;/span&gt;
&lt;span class="sd"&gt;      &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

      &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;

      &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
              &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;
          &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
              &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
              &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;

      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前序遍历的迭代写法
思路：借助栈，弹出根，将根的右节点和左节点入栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;后序遍历的迭代写法
思路：前序遍历是根-&amp;gt;左-&amp;gt;右，根-&amp;gt;右-&amp;gt;左也可以认为是一种前序遍历，而后序遍历左-&amp;gt;右-&amp;gt;根恰好是根-&amp;gt;右-&amp;gt;左的逆序！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;迭代法的统一写法&lt;/h2&gt;
&lt;p&gt;中序遍历的迭代写法难写，本质原因在于节点的访问顺序和处理顺序不一致！&lt;/p&gt;
&lt;p&gt;如何解决呢？可以采用标记法，将访问的节点放入栈中，将处理的节点也放入栈中但要做标记。就是在节点放入栈后，紧接着放入一个空指针作为标记。在出栈时，
遇到空指针节点，就连续弹两次栈，将空指针下面的待处理节点直接输出。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Definition for a binary tree node.&lt;/span&gt;
&lt;span class="c1"&gt;# class TreeNode(object):&lt;/span&gt;
&lt;span class="c1"&gt;#     def __init__(self, val=0, left=None, right=None):&lt;/span&gt;
&lt;span class="c1"&gt;#         self.val = val&lt;/span&gt;
&lt;span class="c1"&gt;#         self.left = left&lt;/span&gt;
&lt;span class="c1"&gt;#         self.right = right&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;postorderTraversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        :type root: TreeNode&lt;/span&gt;
&lt;span class="sd"&gt;        :rtype: List[int]&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
                &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/binary_tree/" rel="alternate"/><published>2021-06-24T00:16:53+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/redis_ha/</id><title>redis高可用</title><updated>2022-09-09T06:20:01.678548+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;过期删除策略&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://zhuanlan.zhihu.com/p/139423463"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定时删除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在设置键的过期时间的同时，创建一个定时器，定时器在键过期时，立即执行对键的删除操作。定时删除可以保证键尽快地被删除，释放占用的空间。&lt;/p&gt;
&lt;p&gt;对内存友好，对cpu非常不友好。创建大量的定时器消耗大量的时间处理键的过期删除，服务器处理命令请求的性能就会降低。目前redis没有使用定时删除策略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;惰性删除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当访问键时，才去检查键是否过期，如果过期就删除键，如果没有过期就返回该键。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定期删除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每隔一段时间，就对数据库进行一次检查，查看哪些键过期，再根据具体策略决定删除哪些键。&lt;/p&gt;
&lt;p&gt;定期删除策略每隔一段时间对键执行过期删除，并通过限制执行删除的时长和频率来减少对cpu的性能影响。&lt;/p&gt;
&lt;h3&gt;redis使用的过期删除策略&lt;/h3&gt;
&lt;p&gt;redis使用的是惰性删除和定期删除策略。&lt;/p&gt;
&lt;p&gt;定期删除的流程为，周期性地执行定期删除函数，每次随机从数据库取出一定数量的键进行检查，并删除其中的过期键。随机删除key的算法，可能是LRU算法。&lt;/p&gt;
&lt;h3&gt;RDB对过期键的处理&lt;/h3&gt;
&lt;p&gt;生成RDB文件时，不会包含过期的键。执行SAVE或BGSAVE命令时，会对键进行检查，已过期的键不会被保存在新创建的RDB文件中。&lt;/p&gt;
&lt;p&gt;载入RDB文件时，主服务器中已过期的键不会被载入内存，从服务器会将所有键载入内存。&lt;/p&gt;
&lt;h3&gt;AOF对过期键的处理&lt;/h3&gt;
&lt;p&gt;如果服务器开启了AOF持久化功能，当键过期被删除时，redis会追加一条DEL命令到AOF文件中，显示标记该键已被删除。&lt;/p&gt;
&lt;p&gt;当执行AOF重写时，已过期的键不会被保存在重写后的AOF文件中。&lt;/p&gt;
&lt;h3&gt;主从复制对过期键的处理&lt;/h3&gt;
&lt;p&gt;从服务器不会触发键过期，而是会等待主节点触发键过期。主节点键过期时，会同步del命令给所有的从节点。
从节点不处理过期键，但也不会返回已过期的数据，会通过独有的逻辑来标记一个键已经过期。&lt;/p&gt;
&lt;h2&gt;主从模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主从复制的过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主节点(master)开启一个子进程，生成rdb快照文件，同时将新的命令写到缓冲区&lt;/li&gt;
&lt;li&gt;向从节点(slave)发送rdb快照文件&lt;/li&gt;
&lt;li&gt;从节点收到rdb文件后，加载数据到内存&lt;/li&gt;
&lt;li&gt;主节点再将缓冲区命令发到从节点，加载后与主节点达到一致状态&lt;/li&gt;
&lt;li&gt;之后主节点每收到一个新的写命令，都会同步给从节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主从复制开始时，副本从主机全量同步数据，发送psync命令，主机执行bgsave，在后台开启一个子进程产生rdb文件，同时将后面新的写命令写到一个缓冲区，然后把rdb文件发送给从机，从机收到后load到内存，这个步骤完成后主机再将缓冲区的数据发给从机，再之后主机收到新的写命令，都会发给从机&lt;/p&gt;
&lt;p&gt;master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。&lt;/p&gt;
&lt;p&gt;增量同步条件：主机会维护一个复制积压缓冲区，如果从节点缺失的数据在复制积压缓冲区内，可以执行增量同步，否则执行全量同步。&lt;/p&gt;
&lt;p&gt;复制积压缓冲区是一个固定长度的先进先出队列，默认大小为1M。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主库执行全量备份会造成毫秒或秒级的卡顿&lt;/li&gt;
&lt;li&gt;COW机制，极端情况下主库内存溢出，程序异常退出或宕机&lt;/li&gt;
&lt;li&gt;发送数GB大小的备份文件导致服务器出口带宽暴增，阻塞请求。&lt;/li&gt;
&lt;li&gt;需要人为手工操作，需要通知业务方做变更配置，整个过程需要人为干预，较为烦琐&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在主-从模式里，如果主服务器宕机了，虽然可以由从机来代替主机继续服务，但这需要人工把从机切换成主机，需要人工干预，还会造成一段时间服务不可用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步复制&lt;/strong&gt;
Redis的主从复制是异步复制，异步分为两个方面，一个是master服务器在将数据同步到slave是异步的，一个是slave在接收同步数据时也是异步的。&lt;/p&gt;
&lt;p&gt;主从复制的模式是异步复制的，主向从发送数据后就返回了，并不等待从成功写入数据。异步复制会导致数据的一致性较差，可能会产生数据丢失。&lt;/p&gt;
&lt;h2&gt;sentinel&lt;/h2&gt;
&lt;p&gt;Sentinel是Redis的高可用性解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;故障转移的过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个sentinel根据心跳响应超时判断主节点是否主观下线，根据配置判定是否客观下线。sentinel判定下线的标准是写在配置里的，包括多久超时，其他sentinel认为下线的数量。&lt;/li&gt;
&lt;li&gt;选举领头sentinel，在每个纪元周期，每个sentinel都可以发送广播让其他sentinel设置自己为领头sentinel；每个sentinel有一次机会设置另一个sentinel为leader；
当某个sentinel获得了半数以上的选票，就成为leader，并发送广播告诉其他sentinel，选举阶段结束。&lt;/li&gt;
&lt;li&gt;领头sentinel选择一台从服务器，将其升级为主服务器。选取的标准有几个。&lt;/li&gt;
&lt;li&gt;向其他从服务器发送命令，让它们复制新的主服务器&lt;/li&gt;
&lt;li&gt;当旧的主服务器重新连线后，将成为新的主服务器的从服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选取从服务器升级为主服务器的标准：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除所有下线或断线的从服务器&lt;/li&gt;
&lt;li&gt;删除最近5秒没有回复info命令的从服务器&lt;/li&gt;
&lt;li&gt;删除与主服务器断开超过一定时间的从服务器，保证数据是相对较新的&lt;/li&gt;
&lt;li&gt;选择优先级最高的&lt;/li&gt;
&lt;li&gt;选择复制偏移量最大的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;sentinel的启动过程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个sentinel都与主服务器建立命令连接和订阅连接。命令连接可以发送info命令，发送publish命令，订阅连接可以接收hello频道的信息&lt;/li&gt;
&lt;li&gt;与主服务器建立连接后，可以向主服务器发送info命令，可以得到从服务器的信息。sentinel就可以无需用户提供从服务器的信息，可以通过主服务器发现从服务器&lt;/li&gt;
&lt;li&gt;发现从服务器后，创建与从服务器的命令连接和订阅连接，也可以向从服务器发送info命令了&lt;/li&gt;
&lt;li&gt;sentinel通过hello频道的信息可以自动发现其他sentinel，相互之间建立命令连接，不建议订阅连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Redis Cluster&lt;/h2&gt;
&lt;p&gt;Redis Cluster是Redis提供的&lt;strong&gt;分布式集群&lt;/strong&gt;解决方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。&lt;/p&gt;
&lt;p&gt;通过Gossip协议进行通信。&lt;/p&gt;
&lt;p&gt;最小配置6个节点以上（3主3从），主节点提供读写操作，从节点作为备用节点，不提供服务，只作为故障转移使用。节点只使用0号数据库&lt;/p&gt;
&lt;p&gt;关键词：节点、槽指派、命令执行、重新分片、转向、故障转移、消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;故障转移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;集群中的每个节点都会定期地向其他节点发送ping消息，以此来检测对方是否在线。如果接收ping消息的节点没有在规定的时间之内回复pong，就会被标记为&lt;strong&gt;疑似下线&lt;/strong&gt;。节点的状态包括：在线，疑似下线，已下线。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果集群里半数以上的负责处理槽的主节点将某个主节点报告为疑似下线，则该节点将被标记为&lt;strong&gt;已下线&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;第一个标记节点为已下线的主节点将向集群广播一条消息，所有收到消息的节点也会立即标记该节点已下线。&lt;/li&gt;
&lt;li&gt;从已下线的主节点下选中一个从节点，使其成为新的主节点。&lt;/li&gt;
&lt;li&gt;新的主节点接管所有旧的主节点的槽，指派给自己。&lt;/li&gt;
&lt;li&gt;向集群广播一条消息，告诉其他节点自己已成为新的主节点，并接管了所有的槽。&lt;/li&gt;
&lt;li&gt;新的主节点开始接收命令和处理自己负责的槽，故障转移完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;选举新的主节点的过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的主节点有投票权，从节点没有投票权&lt;/li&gt;
&lt;li&gt;在某个主节点已下线后，其下的从节点会向集群广播一条消息，要求收到消息的主节点向自己投票。&lt;/li&gt;
&lt;li&gt;每个在线的主节点都有一次投票机会，会选择最先向自己要求投票的从节点。&lt;/li&gt;
&lt;li&gt;当某个从节点获得了半数以上的投票，则选举成功；否则，任何一个从节点都没有获得足够多的选票，会在新的纪元周期发起选举。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;读写分离的讨论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官方默认cluster不进行读写分离。在cluster架构下，默认的，一般redis-master用于接收读写，而redis-slave则用于备份，当有请求是向slave发起时，会直接重定向到对应key的master来处理。&lt;/p&gt;
&lt;p&gt;可通过readonly命令，将slave设置成可读，然后通过slave获取相关的key，达到读写分离。&lt;/p&gt;
&lt;p&gt;不过，通过对master进行水平扩展就可以了，扩容master，跟之前扩容slave并进行读写分离，效果是一样的或者更好。&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/redis_ha/" rel="alternate"/><published>2021-06-24T01:00:23+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/consistency/</id><title>一致性问题</title><updated>2022-09-09T06:20:01.678524+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;一致性问题的产生&lt;/h2&gt;
&lt;p&gt;同一份数据有多份副本，我们面临这样的问题，如何在它们之间同步数据，以便让客户端对数据有一致性的视图。 CAP理论对一致性的定义：每次读请求都能收到最新的数据或者是错误。&lt;/p&gt;
&lt;h2&gt;弱一致性&lt;/h2&gt;
&lt;p&gt;写入数据后，客户端访问可能看不到最新写入的数据，系统优先保证响应速度。弱一致性适合音视频聊天，实时多人游戏等场景。&lt;/p&gt;
&lt;h2&gt;最终一致性&lt;/h2&gt;
&lt;p&gt;写入数据后，客户端访问最终能看到写入的新数据（可能延迟几毫秒），数据被异步复制。 最终一致性在高可用系统中效果不错。&lt;/p&gt;
&lt;h2&gt;强一致性&lt;/h2&gt;
&lt;p&gt;写入数据后，客户端访问到的一定是最新数据。数据被同步复制。 强一致性适合需要事务的场景。&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/consistency/" rel="alternate"/><published>2021-07-14T19:45:39+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/blog_template/</id><title>blog_template</title><updated>2022-09-09T06:20:01.678499+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hexo.io/"&gt;hexo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/blog_template/" rel="alternate"/><published>2021-07-14T19:47:55+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/algorithm_summary/</id><title>算法套路总结</title><updated>2022-09-09T06:20:01.678474+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;二分查找&lt;/h2&gt;
&lt;h2&gt;双指针&lt;/h2&gt;
&lt;p&gt;双指针技巧分为两类，一类是快慢指针，一类是左右指针。&lt;/p&gt;
&lt;h2&gt;滑动窗口&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;size&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;valid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;window的数据类型可以视具体情况而定，比如上述题目都使用哈希表充当计数器，也可以使用一个数组实现同样的效果。&lt;/p&gt;
&lt;p&gt;valid条件是难点，视具体题目而定。&lt;/p&gt;
&lt;h2&gt;哈希表&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://leetcode-cn.com/problems/two-sum/"&gt;TwoSum问题&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;二叉树&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%93%8D%E4%BD%9C%E9%9B%86%E9%94%A6.md"&gt;二叉树集锦&lt;/a&gt;&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/algorithm_summary/" rel="alternate"/><published>2021-07-14T19:52:25+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/ddd/</id><title>领域驱动设计</title><updated>2022-09-09T06:20:01.678450+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content/><link href="/Blog-With-GitHub-Boilerplate/archives/ddd/" rel="alternate"/><published>2021-07-14T19:56:11+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/docker_commands/</id><title>docker commands</title><updated>2022-09-09T06:20:01.678424+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;docker commands&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;attach: Attach local standard input, output, and error streams to a running container&lt;/li&gt;
&lt;li&gt;build: Build an image from a Dockerfile&lt;/li&gt;
&lt;li&gt;commit: Create a new image from a container's changes&lt;/li&gt;
&lt;li&gt;create: Create a new container&lt;/li&gt;
&lt;li&gt;diff: Inspect changes to files or directories on a container's filesystem&lt;/li&gt;
&lt;li&gt;exec: Run a command in a running container&lt;/li&gt;
&lt;li&gt;images: List images&lt;/li&gt;
&lt;li&gt;info: Display system-wide information&lt;/li&gt;
&lt;li&gt;inspect: Return low-level information on Docker objects&lt;/li&gt;
&lt;li&gt;kill: Kill one or more running containers&lt;/li&gt;
&lt;li&gt;login: Log in to a Docker registry&lt;/li&gt;
&lt;li&gt;logout: Log out from a Docker registry&lt;/li&gt;
&lt;li&gt;logs: Fetch the logs of a container&lt;/li&gt;
&lt;li&gt;pause: Pause all processes within one or more containers&lt;/li&gt;
&lt;li&gt;ps: List containers&lt;/li&gt;
&lt;li&gt;pull: Pull an image or a repository from a registry&lt;/li&gt;
&lt;li&gt;push: Push an image or a repository to a registry&lt;/li&gt;
&lt;li&gt;rename: Rename a container&lt;/li&gt;
&lt;li&gt;restart: Restart one or more containers&lt;/li&gt;
&lt;li&gt;rm: Remove one or more containers&lt;/li&gt;
&lt;li&gt;rmi: Remove one or more images&lt;/li&gt;
&lt;li&gt;run: Run a command in a new container&lt;/li&gt;
&lt;li&gt;search: Search the Docker Hub for images&lt;/li&gt;
&lt;li&gt;start: Start one or more stopped containers&lt;/li&gt;
&lt;li&gt;stats: Display a live stream of container(s) resource usage statistics&lt;/li&gt;
&lt;li&gt;stop: Stop one or more running containers&lt;/li&gt;
&lt;li&gt;tag: Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE&lt;/li&gt;
&lt;li&gt;top: Display the running processes of a container&lt;/li&gt;
&lt;li&gt;unpause: Unpause all processes within one or more containers&lt;/li&gt;
&lt;li&gt;update: Update configuration of one or more containers&lt;/li&gt;
&lt;li&gt;version: Show the Docker version information&lt;/li&gt;
&lt;li&gt;wait: Block until one or more containers stop, then print their exit codes&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;docker run&lt;/h2&gt;
&lt;p&gt;使用docker run的时候，通过-v HOST_DIR:CONTAINER_DIR参数来指定数据卷使用的主机目录，这个做法一般被称为“绑定挂载”。
主机目录指运行docker引擎的机器。如果是远程连接到docker服务的话，那么远端的计算机必须已经存在该路径。&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/docker_commands/" rel="alternate"/><published>2021-07-14T19:57:36+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/docker_resource/</id><title>docker资源</title><updated>2022-09-09T06:20:01.678397+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;ul&gt;
&lt;li&gt;Docker官方主页(&lt;a href="http://www.docker.com/)。"&gt;http://www.docker.com/)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker Hub(&lt;a href="http://hub.docker.com)。"&gt;http://hub.docker.com)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker官方博客(&lt;a href="http://blog.docker.com/)。"&gt;http://blog.docker.com/)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker官方文档(&lt;a href="http://docs.docker.com/)。"&gt;http://docs.docker.com/)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker快速入门指南(&lt;a href="https://docs.docker.com/get-started/overview/)。"&gt;https://docs.docker.com/get-started/overview/)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker的GitHub 源代码(&lt;a href="https://github.com/docker/docker)。"&gt;https://github.com/docker/docker)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker Forge(&lt;a href="https://github.com/dockerforge):收集了各种Docker工具、组件和服务。"&gt;https://github.com/dockerforge):收集了各种Docker工具、组件和服务。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker邮件列表(&lt;a href="https://groups.google.com/forum/#!forum/docker-user)。"&gt;https://groups.google.com/forum/#!forum/docker-user)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker的IRC 频道(irc.freenode.net)。&lt;/li&gt;
&lt;li&gt;Docker的Twitter主页(&lt;a href="http://twitter.com/docker)。"&gt;http://twitter.com/docker)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker的StackOverflow问答主页(&lt;a href="http://stackoverflow.com/search?q=docker)。"&gt;http://stackoverflow.com/search?q=docker)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker官网(&lt;a href="http://www.docker.com/)。"&gt;http://www.docker.com/)。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;孙洪亮的 Docker源码分析&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.zhihu.com/pub/book/119564848"&gt;Docker开发指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.zhihu.com/pub/reader/119943940/chapter/1283922533264543744"&gt;Kubernetes权威指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://martinfowler.com/microservices/"&gt;微服务资源指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;微服务设计 Sam Newman&lt;/li&gt;
&lt;/ul&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/docker_resource/" rel="alternate"/><published>2021-07-14T20:01:42+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/health_habbit/</id><title>健康习惯</title><updated>2022-09-09T06:20:01.678367+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;p&gt;【起居有常，饮食有度，远离妄念】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证充足的睡眠。最好是【早睡早起】，比如：11点之前睡，7点起床。&lt;/li&gt;
&lt;li&gt;饮水的【5要】和【5不要】。晨起喝温水，小口喝水，工作时保持喝水，身体不适多喝水，饭前饭后喝水(尽量不在吃饭的时候喝水)。&lt;/li&gt;
&lt;li&gt;生活有规律，合理安排每一天的工作、生活、娱乐、学习。&lt;/li&gt;
&lt;li&gt;避免久坐！！！&lt;/li&gt;
&lt;li&gt;坚持锻炼。&lt;/li&gt;
&lt;li&gt;定期体检。&lt;/li&gt;
&lt;li&gt;注意牙齿健康。饭后及时漱口，晨起喝睡前记得刷牙，必要时借助牙线进行清洁，定期更换牙刷。每半年到一年洗一次牙。&lt;/li&gt;
&lt;li&gt;均衡营养、合理运动、优质睡眠、缓解压力、积极心态。&lt;/li&gt;
&lt;li&gt;注意清洁和保湿，做好这两件事，就足够解决很多皮肤问题。&lt;/li&gt;
&lt;li&gt;学习如何冥想。&lt;/li&gt;
&lt;li&gt;不着急，慢慢来，人生是一场马拉松，活得久的人才有可能取得最后的胜利。&lt;/li&gt;
&lt;li&gt;多抱抱你的家人、爱人、朋友，可以有效缓解压力。&lt;/li&gt;
&lt;li&gt;心存敬畏。敬规律，敬天地，敬良心，敬道德。有所为有所不为，道德底线不能突破。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://ixyzero.com/blog/archives/4874.html"&gt;链接&lt;/a&gt;&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/health_habbit/" rel="alternate"/><published>2021-07-15T17:07:00+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/live_architecture/</id><title>多活架构分析</title><updated>2022-09-09T06:20:01.678314+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;容灾经验分享&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://developer.aliyun.com/article/771429#:~:text=1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%9C%B0%E5%A4%9A,%E4%B8%AD%E5%BF%83%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%88%87%E6%8D%A2%E6%88%90%E5%8A%9F%E3%80%82"&gt;浅谈异地多活及容灾经验分享&lt;/a&gt;
异地多活，英文是Multi-Site High Availability，与传统灾备最主要的区别是“多活”里所有站点都是同时对外提供服务的。&lt;/p&gt;
&lt;p&gt;传统的灾备方案缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统的灾备中心平时不提供服务，关键时刻无法确定切换到灾备中心是否可以切换成功。&lt;/li&gt;
&lt;li&gt;传统的灾备中心平时不提供服务，整个灾备资源处于浪费状态，成本比较高。&lt;/li&gt;
&lt;li&gt;传统的灾备中心平时不提供服务，平时提供服务的数据中心还停留在单地域，当业务体量大到一定程度时，这种模式无法解决单地域资源瓶颈的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“异地多活”在2013年双十一取得了非常好的效果，于是这项技术在业务首次亮相。&lt;/p&gt;
&lt;h3&gt;“多活”和“双活”有什么区别？&lt;/h3&gt;
&lt;p&gt;同样是“双活”，也会因为前面加了“同城”还是“异地”而有着本质的区别。如果是“异地双活”，就和“异地多活”仅存在站点数量上的差别，如果是同城双活，
与异地多活采用的是完全不同的技术。&lt;/p&gt;
&lt;p&gt;同城双活，整个模式应用层是双活的&lt;/p&gt;
&lt;p&gt;常见的多活手段，例如同城双活、两地三中心、三地五中心、异地多活架构设计方案并详述了各种方案的优缺点。&lt;/p&gt;
&lt;p&gt;双机房距离近，通信质量好，底层储存例如mysql可以采用同步复制，有效保证双机房数据一致性。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/vivo_tech/article/details/108552279"&gt;同城双活与异地多活架构分析&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;MySQL的半同步&lt;/h2&gt;
&lt;p&gt;默认情况下，MySQL采用异步复制，主库接收数据后给客户端返回成功，不管备库是否成功接收到数据。这种情况出现数据不一致的可能性就比较大。如果主库宕机，由从库恢复服务就会出现丢失数据的风险。
半同步模式，主库将binlog发给备库，备库写到relay-log后会给主库返回确认，这种情况牺牲部分性能提高了一致性。
完全同步模式，性能最差。&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/live_architecture/" rel="alternate"/><published>2021-07-16T16:24:47+08:06</published></entry></feed>