<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><id>/Blog-With-GitHub-Boilerplate/</id><title>君祁的技术博客</title><updated>2021-06-18T08:34:10.674191+08:06</updated><author><name>君祁</name><email>zqiang33@163.com</email></author><link href="/Blog-With-GitHub-Boilerplate/" rel="alternate"/><generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator><logo>/Blog-With-GitHub-Boilerplate/logo.png</logo><subtitle>只有一种英雄主义，就是看清生活真相之后依然热爱生活。</subtitle><entry><id>/Blog-With-GitHub-Boilerplate/archives/typography/</id><title>Hello World!</title><updated>2021-06-18T08:34:10.674486+00:00</updated><author><name>AlanDecode</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;div class="notice"&gt;这是一篇示例文章，在这里你可以看到常用页面元素的显示效果，同时也是 Markdown 语法的参考文章。保留或者删除本文，开始自己的创作吧！&lt;/div&gt;&lt;h2&gt;L2 Heading&lt;/h2&gt;
&lt;h3&gt;L3 Heading&lt;/h3&gt;
&lt;h4&gt;L4 Heading&lt;/h4&gt;
&lt;h5&gt;L5 Heading&lt;/h5&gt;
&lt;h6&gt;L6 Heading&lt;/h6&gt;
&lt;h2&gt;Paragraph&lt;/h2&gt;
&lt;p&gt;We are creating a world that all may enter without privilege or prejudice accorded by race, economic power, military force, or station of birth.&lt;/p&gt;
&lt;p&gt;We are creating a world where anyone, anywhere may express his or her beliefs, no matter how singular, without fear of being coerced into silence or conformity.&lt;/p&gt;
&lt;h2&gt;Inline elements&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Bold&lt;/strong&gt;, &lt;ruby&gt;Ruby&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;ルビ&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;, &lt;em&gt;Italic&lt;/em&gt;, &lt;del&gt;Strikethrough&lt;/del&gt;, &lt;a href="https://www.imalan.cn"&gt;Link&lt;/a&gt;&lt;sup id="fn_ref_1"&gt;&lt;a href="#fn_1"&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;h2&gt;Blockquote and nested blockquote&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;安得广厦千万间，大庇天下寒士俱欢颜！风雨不动安如山。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;呜呼！何时眼前突兀见此屋，吾庐独破受冻死亦足！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;p&gt;Inline code: &lt;code&gt;int a=1;&lt;/code&gt;. Code block:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hello World!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;List&lt;/h2&gt;
&lt;h3&gt;Unordered List&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;iPhone&lt;ul&gt;
&lt;li&gt;iPhone X&lt;/li&gt;
&lt;li&gt;iPhone 11&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;iPad&lt;/li&gt;
&lt;li&gt;MacBook&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Ordered List&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;打开冰箱&lt;ol&gt;
&lt;li&gt;右手放在冰箱门拉手上&lt;/li&gt;
&lt;li&gt;左手扶住冰箱主体&lt;/li&gt;
&lt;li&gt;右手向后用力&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;把大象放进冰箱&lt;/li&gt;
&lt;li&gt;关上冰箱&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Horizontal rule&lt;/h2&gt;
&lt;hr&gt;
&lt;h2&gt;Math&lt;/h2&gt;
&lt;p&gt;Inline Math: $m\times n$, math block:&lt;/p&gt;
&lt;p&gt;$$C_{m\times k}=A_{m\times n}\cdot B_{n\times k}$$&lt;/p&gt;
&lt;h2&gt;Figures&lt;/h2&gt;
&lt;h3&gt;Single figure&lt;/h3&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="836" data-height="450" src="/Blog-With-GitHub-Boilerplate/archives/assets/e0affbc80ccb2d596c87b520e37e7071.jpg" alt="Princess Mononoke" /&gt;&lt;figcaption&gt;Princess Mononoke&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;Photoset&lt;/h3&gt;
&lt;div class="photos"&gt;
&lt;figure&gt;&lt;img data-width="4032" data-height="2688" src="/Blog-With-GitHub-Boilerplate/archives/assets/4956a144888cdbbb6c2df1d1d15384b0.jpeg" alt="" /&gt;&lt;/figure&gt;
&lt;figure&gt;&lt;img data-width="2690" data-height="2688" src="/Blog-With-GitHub-Boilerplate/archives/assets/4c66f0da616b08325b3aaa4c8b3f68e1.jpg" alt="" /&gt;&lt;/figure&gt;
&lt;figure&gt;&lt;img data-width="4032" data-height="2688" src="/Blog-With-GitHub-Boilerplate/archives/assets/8b4d2334469ffa39b59e6fdb37c8c601.jpeg" alt="" /&gt;&lt;/figure&gt;&lt;/div&gt;&lt;div class="photos"&gt;
&lt;figure&gt;&lt;img data-width="4032" data-height="2688" src="/Blog-With-GitHub-Boilerplate/archives/assets/0f5023d542a33e7c9d270f3cd6a99562.jpeg" alt="" /&gt;&lt;/figure&gt;
&lt;figure&gt;&lt;img data-width="4032" data-height="2688" src="/Blog-With-GitHub-Boilerplate/archives/assets/20ec69d2a0276336f95e11f42866d17f.jpeg" alt="" /&gt;&lt;/figure&gt;
&lt;figure&gt;&lt;img data-width="4032" data-height="2688" src="/Blog-With-GitHub-Boilerplate/archives/assets/2b8af25285e5a193729a350593113bad.jpeg" alt="" /&gt;&lt;/figure&gt;&lt;/div&gt;&lt;h2&gt;Table&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;header&lt;/th&gt;
&lt;th&gt;header&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cell 1&lt;/td&gt;
&lt;td&gt;cell 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cell 3&lt;/td&gt;
&lt;td&gt;cell 4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Link Card&lt;/h2&gt;
&lt;div class="links"&gt;
&lt;a style="display:block" target="_blank" href="https://www.imalan.cn" class="board-item"&gt;                 &lt;div class="board-thumb"&gt;&lt;img src="https://secure.gravatar.com/avatar/1741a6eef5c824899e347e4afcbaa75d?s=200&amp;r=G&amp;d="&gt;&lt;/div&gt;                 &lt;div class="board-title"&gt;AlanDecode&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;&lt;hr&gt;&lt;div class="footnotes"&gt;&lt;ol&gt;&lt;li id="fn_1"&gt;Home page for AlanDecode &lt;a no-style href="#fn_ref_1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><link href="/Blog-With-GitHub-Boilerplate/archives/typography/" rel="alternate"/><published>2019-12-18T16:50:00+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/tcp/</id><title>TCP</title><updated>2021-06-18T08:34:10.674462+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;TCP&lt;/h2&gt;
&lt;p&gt;在socket编程中，当客户端执行&lt;code&gt;connect()&lt;/code&gt;时，将触发三次握手。建立TCP连接时，客户端和服务端，总共需要发送三个包。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一次握手(SYN=1, seq=x)
客户端发送第一个包，SYN标志位为1，序列号为x。发送完毕后，客户端进入&lt;code&gt;SYN_SENT&lt;/code&gt;状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二次握手(SYN=1, ACK=1, seq=y, ACKNum=x+1)
服务端返回确认包并发送一个SYN包，SYN标志位与ACK标志位都设为1，服务端设置自己的序列号y，同时将确认序号设置为客户端的序列号加1，即x+1。发送完毕后，
服务端进入&lt;code&gt;SYN_RCVD&lt;/code&gt;状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三次握手(ACK=1, ACKNum=y+1)
客户端再次发送确认包。ACK标志位设置为1，确认序号设为服务端的序列号加1，即y+1。发送完毕后，客户端进入&lt;code&gt;ESTABLISHED&lt;/code&gt;状态。当服务端收到这个包后，
也进入&lt;code&gt;ESTABLISHED&lt;/code&gt;状态。TCP三次握手过程结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="640" data-height="716" src="/Blog-With-GitHub-Boilerplate/archives/assets/e8772faa1e0dab73cacdd39a590f9539.jpg" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/tcp/" rel="alternate"/><published>2021-06-16T15:07:17+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/mysql/</id><title>MySQL</title><updated>2021-06-18T08:34:10.674437+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;聚簇索引与非聚簇索引&lt;/h2&gt;
&lt;p&gt;聚簇索引(clustered index)：聚簇索引的叶节点存储了整行数据。&lt;/p&gt;
&lt;p&gt;非聚簇索引：索引树的叶子节点只存储索引字段和主键的值，不存放整行数据。非聚簇索引也称为二级索引。&lt;/p&gt;
&lt;p&gt;聚簇索引与非聚簇索引的区别是：是否存放完整的整行记录。&lt;/p&gt;
&lt;p&gt;InnoDB主键使用的是聚簇索引，MyISAM所有的索引（包括主键索引）使用的都是非聚簇索引。&lt;/p&gt;
&lt;h2&gt;MySQL的聚簇索引一定是主键吗？&lt;/h2&gt;
&lt;p&gt;在InnoDB中，聚集索引不一定是主键，但主键一定是聚集索引。如果没有为表定义主键，聚集索引会被设为第一个不为NULL的唯一索引，如果也没有这样的唯一索引，
InnoDB 会选择内置 6 字节长的 ROWID 作为隐含的聚集索引。&lt;/p&gt;
&lt;h2&gt;COUNT(*) COUNT(1) COUNT(id) COUNT(COLUMN)有区别吗？&lt;/h2&gt;
&lt;p&gt;先说结论，在高版本的MySQL（5.5及以后），count(1)比count(*)是没有区别的。&lt;/p&gt;
&lt;p&gt;COUNT(COLUMN)在统计某个列值的数量时，不会统计NULL。当COUNT内的表达式确定不为NULL时，实际上是在统计所有行数。&lt;/p&gt;
&lt;p&gt;如果表只有一个主键索引，没有其他二级索引，那么&lt;code&gt;COUNT(*)&lt;/code&gt;与&lt;code&gt;COUNT(1)&lt;/code&gt;都是通过主键索引统计行数的。如果该表有二级索引，&lt;code&gt;COUNT(*)&lt;/code&gt;与&lt;code&gt;COUNT(1)&lt;/code&gt;
会用&lt;strong&gt;占用空间最小&lt;/strong&gt;的二级索引字段作统计。&lt;/p&gt;
&lt;p&gt;为什么：InnoDB这样操作的原因是为了减少IO次数，因为数据库的瓶颈在IO，通过选择占用空间最小的非NULL索引来统计所有行数，尽可能地减小IO。&lt;/p&gt;
&lt;p&gt;补充：MyISAM在统计表的总行数时会很快，原因是MyISAM对于表的行数作了优化，具体做法有一个变量用于存储表的总行数。但是，如果加了WHERE查询条件，该优化将不起作用。&lt;/p&gt;
&lt;h2&gt;辟谣：MySQL中使用IS NULL, IS NOT NULL, != 不能使用索引？胡扯！&lt;/h2&gt;
&lt;p&gt;NULL值是怎么在记录中存储的：在MySQL中，每一条记录都有固定的格式，以compact格式为会例，在compact格式下，会有一部分记录NULL值列表。NULL值列表是怎么表示的呢？
首先会统计表中所有可以为NULL的列，然后每个允许为NULL的列对应一个二进制位，逆序排列。如果二进制位为1，表示该列的值为NULL,如果为0表示该列的值不为NULL。另外，
二进制位的个数是整数个字节。&lt;/p&gt;
&lt;p&gt;键值为NULL的记录怎么在B+树中存放的？答案是放在B+树的最左边。原因是InnoDB有这样的规定：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;We define the SQL null to be the smallest possible value of a field.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;补充：NULL字段的数据，只能使用IS NULL查询出来，使用= NULL或!= VALUE都不会查出NULL的数据。
当使用COUNT(COLUMN)函数进行统计时，NULL的数据不会被计入统计。
判断列值是否为NULL，必须使用IS NULL和IS NOT NULL。不能使用= NULL或!= NULL，因为在MySQL中，NULL与任何值比较永远返回NULL。&lt;/p&gt;
&lt;h2&gt;有哪些语句会造成MySQL做全表扫描？&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;语句&lt;/th&gt;
&lt;th&gt;是否使用索引&lt;/th&gt;
&lt;th&gt;是否使用全表扫描&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;IS NULL&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IS NOT NULL&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IN&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NOT IN&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COUNT(*)&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LIKE '%xxx'&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使不使用索引的依据是什么？&lt;/p&gt;
&lt;p&gt;IS NULL、IS NOT NULL、!=这些条件都可能使用到索引，那到底什么时候索引，什么时候采用全表扫描呢？&lt;/p&gt;
&lt;p&gt;答案是：数据库会根据查询的成本决定何时走索引查询，何时做全表扫描。对二级索引来说，成本主要有两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取二级索引记录的成本&lt;/li&gt;
&lt;li&gt;执行回表操作的成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当执行回表操作的次数比较多，达到一定比例时，数据库经过计算分析使用二级索引再回表的查询成本超过了全表扫描的成本，就会使用全表扫描。&lt;/p&gt;
&lt;h2&gt;InnoDB的事务隔离是如何实现的？&lt;/h2&gt;
&lt;h3&gt;四种隔离级别&lt;/h3&gt;
&lt;p&gt;未提交读(read uncommitted)，提交读(read committed)，可重复读(repeatable read)，串行化(serializable)。&lt;/p&gt;
&lt;p&gt;标准SQL事务隔离级别的实现是依赖锁的，但使用锁的方式实现隔离级别需要频繁地加解锁，很容易出现读写冲突。为了不加锁解决读写冲突的问题，MySQL引入的MVCC机制。
在读提交和可重复读的隔离级别下，InnoDB会创建一个视图（快照），访问数据的时候以视图的逻辑结果为准。在可重复读的隔离级别下，这个视图是在事务启动时创建的。
在读提交的隔离级别下，视图是在每条sql语句开始执行时创建的。在读未提交的隔离级别下，不提供隔离措施，不会创建视图，但更新某行数据时加共享锁。
串行化的隔离级别是通过加锁的方式避免并行访问。&lt;/p&gt;
&lt;h3&gt;锁定读和一致性非锁定读&lt;/h3&gt;
&lt;p&gt;锁定读：在一个事务中进行查询时，主动给读加锁。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SELECT ... LOCK IN SHARE MODE  &lt;span class="c1"&gt;# 加了行共享锁&lt;/span&gt;
SELECT ... FOR UPDATE  &lt;span class="c1"&gt;# 加了行排他锁&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一致性非锁定读：
事务在进行查询时，数据库通过使用MVCC提供某个时间点的数据快照，查询会看到该时间点之前事务对数据的更改，而不会看到该时间点之后事务对数据的更改或未提交的更改。
consistent read是InnoDB在RC和RR隔离级别下进行SELECT查询的默认模式。&lt;/p&gt;
&lt;h3&gt;当前读和快照读&lt;/h3&gt;
&lt;p&gt;当前读：当前读读取的是数据的最新版本，像UPDATE, DELETE, INSERT, SELECT ... LOCK IN SHARE MODE, SELECT ... FOR UPDATE等操作都是当前读。
当前读要保证其他并发事务不会修改当前读取的数据，会对相应记录加锁。&lt;/p&gt;
&lt;p&gt;快照读：快照读读取的数据是快照版本，也就是历史版本，像不加锁的SELECT就是快照读。快照读的前提是不在未提交读和串行化的隔离级别下，因为未提交读问题读取最新的数据，串行化则是对表加锁。&lt;/p&gt;
&lt;h3&gt;InnoDB对事务的实现&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;事务隔离级别&lt;/th&gt;
&lt;th&gt;实现方式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;未提交读&lt;/td&gt;
&lt;td&gt;读数据不加锁，都是当前读；更新数据，加行级共享锁，直到事务结束才释放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;提交读&lt;/td&gt;
&lt;td&gt;读数据不加锁，都是快照读；更新数据，加行级排他锁，直到事务结束才释放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可重复读&lt;/td&gt;
&lt;td&gt;读数据不加锁，都是快照读；更新数据时，加行级排他锁，间隙锁，直到事务结束才释放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;串行化&lt;/td&gt;
&lt;td&gt;读取数据时，加表级共享锁，都是当前读；更新数据时，加表级排他锁，直到事务结束才释放&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在RR隔离级别下，InnoDB通过快照读，解决了不可重复读的问题，通过间隙锁，解决了幻读的问题。
通过MVCC，InnoDB可以在RC隔离级别解决不可重复读的问题，可以在RR隔离级别解决幻读的问题。&lt;/p&gt;
&lt;h3&gt;只靠MVCC是否能解决幻读的问题？&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;begin;

#假设users表为空，下面查出来的数据为空

select * from users; #没有加锁

#此时另一个事务提交了，且插入了一条id=1的数据

select * from users; #读快照，查出来的数据为空

update users set name='mysql' where id=1;#update是当前读，所以更新成功，并生成一个更新的快照

select * from users; #读快照，查出来id为1的一条记录，因为MVCC可以查到当前事务生成的快照

commit;&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;begin;

#假设users表为空，下面查出来的数据为空

select * from users lock in share mode; #加上共享锁

#此时另一个事务B想提交且插入了一条id=1的数据，由于有间隙锁，所以要等待

select * from users; #读快照，查出来的数据为空

update users set name='mysql' where id=1;#update是当前读，由于不存在数据，不进行更新

select * from users; #读快照，查出来的数据为空

commit;

#事务B提交成功并插入数据&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意: RR模式下想解决幻读问题，需要我们显式加锁，不然查询的时候还是不会加锁的。&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/mysql/" rel="alternate"/><published>2021-06-16T15:07:17+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/http/</id><title>HTTP</title><updated>2021-06-18T08:34:10.674413+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;HTTP2的特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;多路复用&lt;/li&gt;
&lt;li&gt;头部压缩&lt;/li&gt;
&lt;li&gt;服务器推送&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多路复用允许单一的连接同时发起多重的请求-响应。
实现的原理是通过二进制分帧，HTTP/2将所有传输的信息分割为帧，并对它们采用二进制格式的编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;头部压缩的原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在HTTP/1中，请求和响应都是由状态行、请求/响应头部、消息主体三部分组成，一般消息主体都会经过gzip压缩，或者本身就是经过压缩后的二进制文件（图片、
音频），但状态行和头部却是以纯文本传输的，没有经过任何的压缩。&lt;/p&gt;
&lt;p&gt;HTTP/2对头部数据也进行了压缩，并且在客户端和服务端之间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护一份相同的静态字典，包含常见的头部名称，以及特别常见的头部名称与值的组合。&lt;/li&gt;
&lt;li&gt;维护一份相同的动态字典，可以动态地添加内容。&lt;/li&gt;
&lt;li&gt;支持哈夫曼编码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于完全匹配的头部键值对，例如method: GET，可以直接使用一个字符表示。&lt;/li&gt;
&lt;li&gt;对于头部名称可以匹配的键值对，例如cookie: xxx，可以将名称使用一个字符表示。&lt;/li&gt;
&lt;li&gt;对于不完全匹配静态字典的键值对，可以添加到动态字典中，在后续的请求中也可以使用一个字符表示了。&lt;/li&gt;
&lt;li&gt;对于在静态、动态字典中都不存在的内容，可以使用哈夫曼编码来减小体积。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;HTTP1.1的pipeline与HTTP/2的多路复用有什么区别？&lt;/h2&gt;
&lt;p&gt;网上有一张图，对HTTP1.1与HTTP/2在网络通信的差异进行了对比。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1602" data-height="1588" src="/Blog-With-GitHub-Boilerplate/archives/assets/08f37543e79bd131bd11b266e61b719b.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;HTTP1.0使用的是短连接，每次请求响应完成会断开连接，效率非常低。&lt;/p&gt;
&lt;p&gt;HTTP1.1增加了支持持久化连接，也就是长连接，在一个连接上可以进行多次请求/响应。但是多个请求/响应只能串行，后一个请求/响应只能在前一个请求/响应完成后才能发起。&lt;/p&gt;
&lt;p&gt;HTTP1.1提供了管线化技术，可以将多个http请求打包在一起发给服务端，但是返回的响应也必须是按请求的顺序返回，如果某个请求耗时很长，就会阻塞后面的请求，有队头阻塞问题。&lt;/p&gt;
&lt;p&gt;HTTP/2提出了多路复用技术，在一个tcp连接上可以并行多个请求/响应，不同请求/响应之间互不影响。原理是将消息分成多个二进制帧，二进制帧带有更多信息，标识自己属于哪个请求/响应，
这样多个请求/响应可以并行处理，不会相互阻塞。&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/http/" rel="alternate"/><published>2021-06-17T14:47:10+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/hashmap/</id><title>HashMap的实现原理</title><updated>2021-06-18T08:34:10.674389+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;p&gt;&lt;a href="https://blog.csdn.net/weixin_44015043/article/details/105346187"&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;HashMap的实现原理&lt;/h2&gt;
&lt;p&gt;JDK1.7中使用的是数组+链表。&lt;/p&gt;
&lt;p&gt;JDK1.8中使用的是数组+链表+红黑树。当链表长度大于8时，会将链表转化为红黑树；当链表长度小于6时，会将红黑树转化为链表。&lt;/p&gt;
&lt;p&gt;算法过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据key的hashcode做散列，计算出数组内对应的下标值。&lt;/li&gt;
&lt;li&gt;如果数组中对应的位置为空，说明没有发生哈希碰撞冲突，就直接放在该位置。&lt;/li&gt;
&lt;li&gt;如果发生了哈希碰撞，且下面是链表结构，链表长度小于8，就放到链表里（JDK1.8放在尾部，JDK1.7放在头部）；如果添加后链表长度大于8，
就将链表转化为红黑树的结构。&lt;/li&gt;
&lt;li&gt;如果发生了哈希碰撞，且下面是红黑树结构，就将新元素插入到红黑树中。&lt;/li&gt;
&lt;li&gt;进行扩容检测，如果需要扩容，将数组进行2倍扩容，并将老数组中的所有元素取出来重新进行hash散列，再放到新数组中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="634" data-height="441" src="/Blog-With-GitHub-Boilerplate/archives/assets/5429d84584ae3be5f41df2a60e2289a0.jpg" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;为什么使用数组而不是链表？&lt;/h2&gt;
&lt;p&gt;数组的查询时间复杂度是O(1)，通过散列函数计算出数组的下标，可以直接定位到节点的位置。&lt;/p&gt;
&lt;p&gt;使用底层数组，不使用ArrayList，可以自定义扩容机制，而ArrayList是1.5倍扩容。&lt;/p&gt;
&lt;h2&gt;如何计算数组的下标值？&lt;/h2&gt;
&lt;p&gt;根据key取得hashcode后，将它与数组的长度减1进行与运算，得出下标值。
进行与操作时，计算只用到了最后几位，导致所生成的下标值不能够完全散列。
解决方式是将hashcode的高16位与低16位进行异或操作，得到的值再进行相与，得到最终散列的下标值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hashCode&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tab&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;tab&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/hashmap/" rel="alternate"/><published>2021-06-17T14:47:10+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/redis/</id><title>redis设计与实现</title><updated>2021-06-18T08:34:10.674364+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;简单动态字符串(SDS)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sdshdr&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;常数时间获取字符串长度。&lt;/li&gt;
&lt;li&gt;杜绝缓冲区溢出。&lt;/li&gt;
&lt;li&gt;通过内存预分配和惰性空间释放减少内存重分配次数。&lt;/li&gt;
&lt;li&gt;二进制安全。&lt;/li&gt;
&lt;li&gt;兼容部分c字符串函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;链表&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;listNode&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;listNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;listNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;listNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;list&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;listNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;listNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dup&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;双端&lt;/li&gt;
&lt;li&gt;无环&lt;/li&gt;
&lt;li&gt;带表头和表尾指针&lt;/li&gt;
&lt;li&gt;长度计数器&lt;/li&gt;
&lt;li&gt;多态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;跳跃表&lt;/h2&gt;
&lt;p&gt;链接：&lt;a href="https://www.jianshu.com/p/9d8296562806"&gt;跳跃表的实现（全网最详细的分析）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;zskiplistNode&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;zskiplistNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;backward&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;score&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;robj&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;zskiplistLevel&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;skiplistNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;span&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="p"&gt;[];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;skiplistNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;zskiplist&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;zskiplistNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 表头节点的层高不会记录&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;zskiplist&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;跳跃表由以下几部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表头：不存储元素，负责维护指向第一个元素各层的指针。&lt;/li&gt;
&lt;li&gt;表尾：全部由NULL组成，表示每一层链表的结尾。&lt;/li&gt;
&lt;li&gt;跳跃表节点：保存元素值，以及多个层。&lt;/li&gt;
&lt;li&gt;层：保存指向其他层的指针。高层的指针越过的元素数量大于等于低层的指针。查询时总是从高层的先开始搜索，然后慢慢降低层次，直到找到相应的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="-1" data-height="-1" src="https://user-gold-cdn.xitu.io/2019/6/17/16b650948652b4ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="跳跃表的数据结构" /&gt;&lt;figcaption&gt;跳跃表的数据结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;跳跃表的查询复杂度可以接近O(logN)。
跳跃表的查询效率可以与平衡树媲美，但设计与实现却比平衡树简单得多。设计思想是通过空间换时间。通过建立多层链表，高层的链表比低层的跨度大，就可以加快查询速度。&lt;/p&gt;
&lt;p&gt;当有序集合中元素数量很多，或者元素的成员是较长的字符串，就会使用跳跃表作为底层实现。&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/redis/" rel="alternate"/><published>2021-06-17T17:15:16+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/java_function_program/</id><title>聊聊Java8的函数式编程</title><updated>2021-06-18T08:34:10.674337+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;p&gt;函数式编程是Java8的一大特色。&lt;/p&gt;
&lt;h2&gt;Stream&lt;/h2&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/java_function_program/" rel="alternate"/><published>2021-06-18T10:30:05+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/mysql_index/</id><title>谈谈数据库的索引</title><updated>2021-06-18T08:34:10.674308+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;索引有哪几种实现的方式？&lt;/h2&gt;
&lt;p&gt;索引的实现方式有很多种，常见的三种数据结构是哈希表、有序数组和搜索树。&lt;/p&gt;
&lt;p&gt;哈希表的查询复杂度可以接近O(1)，适合做等值查询，但做范围查询要做全表扫描，效率非常低。&lt;/p&gt;
&lt;p&gt;有序数组做等值查询和范围查询效率都很高，但更新数据的成本很高。&lt;/p&gt;
&lt;p&gt;平衡二叉搜索树的查询和更新时间复杂度都是O(logN)。但二叉树的高度可能很高，查询时需要访问多个数据块，就会有多次读取磁盘的操作。为了让一个查询尽量少地读磁盘， 
应该使用N叉树（多路查找树），使索引树的高度尽量少。一般树根的数据块会加载到内存，一个高度为4的N叉树只需要3次访问磁盘。N叉树由于在读写上的性能优点，
以及适配磁盘的访问模式，被广泛应用在数据库引擎中。&lt;/p&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/mysql_index/" rel="alternate"/><published>2021-06-18T10:45:11+08:06</published></entry><entry><id>/Blog-With-GitHub-Boilerplate/archives/mysql_ha/</id><title>MySQL高可用</title><updated>2021-06-18T08:34:10.674256+00:00</updated><author><name>君祁</name><email>zqiang33@163.com</email><uri>https://www.imalan.cn</uri></author><content>&lt;h2&gt;主从复制的过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;master开启binlog功能。&lt;/li&gt;
&lt;li&gt;master开启io线程，slave开启io线程，sql线程。&lt;/li&gt;
&lt;li&gt;master通过io线程将binlog日志发送到slave，slave通过io线程接收binlog数据，将其写入relay-log（中继日志）。&lt;/li&gt;
&lt;li&gt;slave的sql线程实时监测relay-log的内容是否有更新，如果有更新，将里面的sql语句重新执行生成相应的数据。&lt;/li&gt;
&lt;/ol&gt;
</content><link href="/Blog-With-GitHub-Boilerplate/archives/mysql_ha/" rel="alternate"/><published>2021-06-18T16:00:26+08:06</published></entry></feed>