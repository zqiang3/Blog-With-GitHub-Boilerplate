---
layout: post
title: 数据库锁
slug: mysql_index
date: 2021-06-18 10:45:11
status: publish
author: 君祁
categories:
- 数据库
tags:
- mysql
- index
excerpt: mysql index
---

## Reference
https://juejin.cn/post/6866598870332702728

mysql支持两种类型的读锁，提供额外的安全性
lock in share mode
给当前数据加共享锁，在当前事务提交前，不能修改加了共享锁的行。
如果这些行被另一个尚未提交的事务更改，则当前事务将会等待直到更改事务结束，然后使用最新值。


## 幻读
幻读专指出现了新插入的行。

出现幻读一是破坏了行锁的语义，二是破坏了数据的一致性。

出现幻读的原因：行锁只能锁定已经存在的行，而不能锁定未插入的行。

## 间隙锁
间隙锁锁定了行与行之间的间隙，可以用于解决幻读问题，但也带来了一些新的问题，比如：降低并发度，可能导致死锁。

间隙锁之前是不冲突的，间隙锁会阻塞插入的操作。

间隙锁主要用于防止幻读，主要通过两个方面来实现这个目的
1. 防止间隙内有新数据插入
2. 防止已存在的数据，更新成间隙内的数据

使用间隙锁的条件
1. 必须在RR级别下
2. 检索条件必须有索引（如果没有索引，mysql会全表扫描，锁住整张表，包括不存在的记录，此时其他事务不能修改不能删除不能添加）

## next-key lock
next-key锁包含了记录锁（也叫行锁）和间隙锁，锁定一个范围，并锁定本身。InnoDB默认加锁的范围就是next-key锁。

## 悲观锁与乐观锁
悲观锁与乐观锁是两种不同的思想，用于解决并发场景下的数据竞争问题。

悲观锁需要加真实的锁，读取数据时加共享锁（读锁），写数据时加排他锁（写锁）。

乐观锁并不真正加锁，只是在更新数据的时候判断一下数据是不是已经被修改，如果数据被修改则放弃操作，否则执行操作。

**乐观锁的实现方式**
* CAS
* 版本号

CAS操作逻辑如下：如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。

版本号机制的基本思路是在数据中增加一个字段version，表示数据的版本号，每当数据被修改时，版本号加1。当查询数据时，将该数据的版本号一起查出来；
更新数据时，判断一下当前版本号与之前读取的版本号是否一致，如果一致才进行操作，否则放弃操作。

**CAS缺点**
* ABA问题
* 如果并发冲突严重，CAS机制会频繁失败，一直重试，消耗CPU严重。
* CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的。


## InnoDB加锁处理分析
[链接](https://tech.meituan.com/2014/08/20/innodb-lock.html)

MVCC(Multi-Version Concurrency Control)：多版本并发控制
Lock-Based Concurrency Control：基于锁的并发控制

两段锁：加锁阶段和解锁阶段

MVCC的好处：读不加锁，读写不冲突，极大地提高系统的并发能力。

**索引对加锁的影响**

考虑下面的表和更新语句
```
create table t(
c int
);

insert into t values(1);
insert into t values(5);
insert into t values(10);

update t set c = 100 where c = 1;

alter table t add index id_c (c);
```
c字段加索引与不加索引有区别吗？事实上，如果不给c字段加索引，上面的更新语句会把整张表的所有数据行加行锁。这听起来有点不可思议，但是sql运行过程中，
由于没有索引，存储引擎无法通过索引快速过滤，就会将所有记录加锁后，全部返回给server层进行过滤。

但在实际使用过程当中，MySQL做了一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录释放锁 (违背了二段锁协议的约束)。
这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。可见即使是MySQL，为了效率也是会违反规范的。（参见《高性能MySQL》中文第三版p181）


## 我只改一行语句为什么锁这么多？
加锁规则，通过查看MySQL代码总结而来

前提：基于MySQL最新版本，5.x系列<=5.7.24，8.0系列 <=8.0.13。

两个原则，两个优化，一个bug。
* 原则1：加锁的基本单位是next-key lock，next-key lock是前开后闭区间。
* 原则2：查找过程中只有**访问到的字段**才会加锁。
* 优化1：索引上的等值查询，如果是唯一索引且存在这个值，next-key lock退化为行锁。
* 优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。
* 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

举例说明
```bash
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```



| 时刻 | 会话A                                   | 会话B                                 | 会话C                                 |
| ---- | --------------------------------------- | ------------------------------------- | ------------------------------------- |
| t1   | begin; update t set d = d+1 where id=7; |                                       |                                       |
| t2   |                                         | Insert into t values(8,8,8);(blocked) |                                       |
| T3   |                                         |                                       | update t set d = d+1 where id=10;(OK) |


| 时刻 | 会话A                                   | 会话B                                 | 会话C                                 |
| ---- | --------------------------------------- | ------------------------------------- | ------------------------------------- |
| t1   | begin; select id from t where c = 5 lock in share mode; |                                       |                                       |
| t2   |                                         | update t set d = d + 1 where id = 5; (OK) |                                       |
| T3   |                                         |                                       | insert into t values(7,7,7); (blocked) |

lock in share mode只锁覆盖索引，但是for update就不一样了。执行for update时，系统会认为接下来你会更新数据，会在主键索引上将满足条件的行中上行锁。

## 参考链接
https://quguang.wang/post/mysql-next-key-lock/