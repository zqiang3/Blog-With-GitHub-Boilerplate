---
layout: post
title: MySQL
slug: mysql
date: 2021-06-16 15:07:17
status: publish
author: 君祁
categories:
  - Maverick 
tags:
  - 数据库
  - MySQL
excerpt: MySQL原理
---

## 聚簇索引与非聚簇索引
聚簇索引(clustered index)：聚簇索引的叶节点存储了整行数据。

非聚簇索引：索引树的叶子节点只存储索引字段和主键的值，不存放整行数据。非聚簇索引也称为二级索引。

聚簇索引与非聚簇索引的区别是：是否存放完整的整行记录。

InnoDB主键使用的是聚簇索引，MyISAM所有的索引（包括主键索引）使用的都是非聚簇索引。

## MySQL的聚簇索引一定是主键吗？
在InnoDB中，聚集索引不一定是主键，但主键一定是聚集索引。如果没有为表定义主键，聚集索引会被设为第一个不为NULL的唯一索引，如果也没有这样的唯一索引，
InnoDB 会选择内置 6 字节长的 ROWID 作为隐含的聚集索引。

## COUNT(*) COUNT(1) COUNT(id) COUNT(COLUMN)有区别吗？
先说结论，在高版本的MySQL（5.5及以后），count(1)比count(*)是没有区别的。

COUNT(COLUMN)在统计某个列值的数量时，不会统计NULL。当COUNT内的表达式确定不为NULL时，实际上是在统计所有行数。

如果表只有一个主键索引，没有其他二级索引，那么`COUNT(*)`与`COUNT(1)`都是通过主键索引统计行数的。如果该表有二级索引，`COUNT(*)`与`COUNT(1)`
会用**占用空间最小**的二级索引字段作统计。

为什么：InnoDB这样操作的原因是为了减少IO次数，因为数据库的瓶颈在IO，通过选择占用空间最小的非NULL索引来统计所有行数，尽可能地减小IO。

补充：MyISAM在统计表的总行数时会很快，原因是MyISAM对于表的行数作了优化，具体做法有一个变量用于存储表的总行数。但是，如果加了WHERE查询条件，该优化将不起作用。

## 辟谣：MySQL中使用IS NULL, IS NOT NULL, != 不能使用索引？胡扯！
NULL值是怎么在记录中存储的：在MySQL中，每一条记录都有固定的格式，以compact格式为会例，在compact格式下，会有一部分记录NULL值列表。NULL值列表是怎么表示的呢？
首先会统计表中所有可以为NULL的列，然后每个允许为NULL的列对应一个二进制位，逆序排列。如果二进制位为1，表示该列的值为NULL,如果为0表示该列的值不为NULL。另外，
二进制位的个数是整数个字节。

键值为NULL的记录怎么在B+树中存放的？答案是放在B+树的最左边。原因是InnoDB有这样的规定：
>We define the SQL null to be the smallest possible value of a field.

补充：NULL字段的数据，只能使用IS NULL查询出来，使用= NULL或!= VALUE都不会查出NULL的数据。
当使用COUNT(COLUMN)函数进行统计时，NULL的数据不会被计入统计。
判断列值是否为NULL，必须使用IS NULL和IS NOT NULL。不能使用= NULL或!= NULL，因为在MySQL中，NULL与任何值比较永远返回NULL。


## 有哪些语句会造成MySQL做全表扫描？
| 语句 | 是否使用索引 | 是否使用全表扫描 |
| --- | --- | --- |
| IS NULL | 可能 | 可能 |
| IS NOT NULL | 可能 | 可能 |
| !=  | 可能 | 可能 |
| IN  | 可能 | 可能 |
| NOT IN | 可能 | 可能 |
| COUNT(*)  | 否 | 是 |
| LIKE '%xxx' | 否 | 是 |
使不使用索引的依据是什么？

IS NULL、IS NOT NULL、!=这些条件都可能使用到索引，那到底什么时候索引，什么时候采用全表扫描呢？

答案是：数据库会根据查询的成本决定何时走索引查询，何时做全表扫描。对二级索引来说，成本主要有两个方面：
* 读取二级索引记录的成本
* 执行回表操作的成本

当执行回表操作的次数比较多，达到一定比例时，数据库经过计算分析使用二级索引再回表的查询成本超过了全表扫描的成本，就会使用全表扫描。

## InnoDB的事务隔离是如何实现的？
### 四种隔离级别
未提交读(read uncommitted)，提交读(read committed)，可重复读(repeatable read)，串行化(serializable)。

标准SQL事务隔离级别的实现是依赖锁的，但使用锁的方式实现隔离级别需要频繁地加解锁，很容易出现读写冲突。为了不加锁解决读写冲突的问题，MySQL引入的MVCC机制。
在读提交和可重复读的隔离级别下，InnoDB会创建一个视图（快照），访问数据的时候以视图的逻辑结果为准。在可重复读的隔离级别下，这个视图是在事务启动时创建的。
在读提交的隔离级别下，视图是在每条sql语句开始执行时创建的。在读未提交的隔离级别下，不提供隔离措施，不会创建视图，但更新某行数据时加共享锁。
串行化的隔离级别是通过加锁的方式避免并行访问。

### 锁定读和一致性非锁定读
锁定读：在一个事务中进行查询时，主动给读加锁。
```bash
SELECT ... LOCK IN SHARE MODE  # 加了行共享锁
SELECT ... FOR UPDATE  # 加了行排他锁
```

一致性非锁定读：
事务在进行查询时，数据库通过使用MVCC提供某个时间点的数据快照，查询会看到该时间点之前事务对数据的更改，而不会看到该时间点之后事务对数据的更改或未提交的更改。
consistent read是InnoDB在RC和RR隔离级别下进行SELECT查询的默认模式。

### 当前读和快照读
当前读：当前读读取的是数据的最新版本，像UPDATE, DELETE, INSERT, SELECT ... LOCK IN SHARE MODE, SELECT ... FOR UPDATE等操作都是当前读。
当前读要保证其他并发事务不会修改当前读取的数据，会对相应记录加锁。

快照读：快照读读取的数据是快照版本，也就是历史版本，像不加锁的SELECT就是快照读。快照读的前提是不在未提交读和串行化的隔离级别下，因为未提交读问题读取最新的数据，串行化则是对表加锁。

### InnoDB对事务的实现

|  事务隔离级别    | 实现方式 |
| ---- | ---- |
|  未提交读    |   读数据不加锁，都是当前读；更新数据，加行级共享锁，直到事务结束才释放   |
|  提交读    | 读数据不加锁，都是快照读；更新数据，加行级排他锁，直到事务结束才释放 |
| 可重复读     | 读数据不加锁，都是快照读；更新数据时，加行级排他锁，间隙锁，直到事务结束才释放     |
|  串行化    |  读取数据时，加表级共享锁，都是当前读；更新数据时，加表级排他锁，直到事务结束才释放    |

在RR隔离级别下，InnoDB通过快照读，解决了不可重复读的问题，通过间隙锁，解决了幻读的问题。
通过MVCC，InnoDB可以在RC隔离级别解决不可重复读的问题，可以在RR隔离级别解决幻读的问题。

### 只靠MVCC是否能解决幻读的问题？
```
begin;

#假设users表为空，下面查出来的数据为空

select * from users; #没有加锁

#此时另一个事务提交了，且插入了一条id=1的数据

select * from users; #读快照，查出来的数据为空

update users set name='mysql' where id=1;#update是当前读，所以更新成功，并生成一个更新的快照

select * from users; #读快照，查出来id为1的一条记录，因为MVCC可以查到当前事务生成的快照

commit;
```

```
begin;

#假设users表为空，下面查出来的数据为空

select * from users lock in share mode; #加上共享锁

#此时另一个事务B想提交且插入了一条id=1的数据，由于有间隙锁，所以要等待

select * from users; #读快照，查出来的数据为空

update users set name='mysql' where id=1;#update是当前读，由于不存在数据，不进行更新

select * from users; #读快照，查出来的数据为空

commit;

#事务B提交成功并插入数据
```
注意: RR模式下想解决幻读问题，需要我们显式加锁，不然查询的时候还是不会加锁的。